\documentclass{llncs}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{slatex}

\title{Instant Continuation Marks--Just Add $\lambda$}

\author{Kimball Germane \and Jay McCarthy}
\institute{Brigham Young University}

% Look at the many other papers on c marks to justify them (see mine for
% example). Talk about how your transformation is a compiler and right
% now no language but Racket has C-marks, so we could use this to get
% them in that language. For Racket though, now they don't need to be
% built in to the compiler if we don't want. In addition, it makes it
% easier to do a type system.

\setkeyword{wcm ccm with-continuation-mark current-continuation-marks}
\setkeyword{print fac zero?}

\newcommand{\cm}[0]{$\lambda_{cm}$}
\newcommand{\lv}[0]{$\lambda_v$}
\newcommand{\lc}[0]{$\lambda$-calculus}
\newcommand{\wcm}[2]{(\mathrm{wcm}\,#1\,#2)}
\newcommand{\ccm}[0]{(\mathrm{ccm})}
\newcommand{\app}[2]{(#1\,#2)}
\newcommand{\abs}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\hole}[0]{\bullet}
\newcommand{\rr}[0]{\rightarrow}
\newcommand{\lrrs}[0]{\rightarrow^{*}}
\newcommand{\lvrr}[0]{\rightarrow_v}
\newcommand{\lvrrs}[0]{\rightarrow_v^{*}}
\newcommand{\cmrr}[0]{\rightarrow_{cm}}
\newcommand{\cmrrs}[0]{\rightarrow_{cm}^{*}}
\newcommand{\C}[1]{\mathcal{C}[#1]}

\begin{document}

\maketitle

\begin{abstract}
Continuation marks are a programming language feature which generalizes stack inspection. Despite its usefulness, this feature has not been adopted by languages which rely on stack inspection, e.g., for dynamic security checks. One reason for this neglect may be that continuation marks do not yet enjoy a transformation to the plain $\lambda$-calculus which would allow higher-order languages to provide continuation marks at little cost.

We present direct and CPS-like transformations from the call-by-value $\lambda$-calculus augmented with continuation marks to the pure call-by-value $\lambda$-calculus. We discuss how such transformations would simplify the construction of compilers which treat continuation marks correctly. We document the aide of Redex, a domain-specific language for exploring language semantics, in the discovery of correct transformations. Finally, we verify the transformations with the proof of a meaning-preservation theorem.
\end{abstract}

\section{Introduction}

There are numerous programming language instruments which rely on stack inspection to function. For example, statistical profilers sample the stack regularly to record active functions, algebraic steppers observe the stack to represent the evaluation context of an expression, and debuggers naturally require consistent access to the stack. Each of these examples relies on implementation-specific information and must be maintained as the instrumented language undergoes optimizations and ventures across platforms. This makes these tools brittle and increases the porting cost of the language ecosystem. Each of these examples would benefit from a generalized stack-inspection mechanism available within the instrumented language itself. If written in such an enhanced language, each instrument would be more robust and port for free.

Continuation marks \cite{clements2006portable} are a programming language feature which generalizes stack inpection. Not only do they dramatically simplify correct instrumentation \cite{clements2001modeling}, they have been used to allow inspection-based dynamic security checks in the presence of tail-call optimization \cite{clements2004tail} and to express aspect-oriented programming in higher-order languagues \cite{tucker2003pointcuts}.

Continuation marks originated in PLT Scheme (now Racket \cite{plt-tr1}) and have been added experimentally to \emph{JavaScript} \cite{clements2008implementing}. However, in spite of their usefulness, continuation marks have remained absent from programming languages at large. One reason for this may be that continuation marks do not yet enjoy a transformation to the \lc. With a correct transformation, higher-order language semanticists would not need to reconcile the feature with other features in the language (provided they had already done so with $\lambda$) and their compiler-writers would not need to worry about complicating their implementations (for the same reason).

We present two transformations of continuation marks--one direct and one CPS-like--to the call-by-value \lc. We employ Redex, a domain-specific semantic meta-language, to provide feedback through randomized testing and reduction trace visualization.

\section{Background}

\subsection{Continuation Marks}

Continuation marks allow the program to annotate and observe the stack (or continuation). This is accomplished via two surface-level syntactic forms in the language: \scheme'with-continuation-mark', abbreviated \scheme'wcm'; and \scheme'current-continuation-marks', abbreviated \scheme'ccm'.

A \scheme'wcm' expression of the form \scheme|(wcm mark-expr body-expr)| annotates the youngest portion of the continuation with \scheme'mark-value', the evaluation of \scheme'mark-expr', before evaluating \scheme'body-expr' to \scheme'body-value'. If an annotation, or \emph{mark}, already exists on the youngest portion, it is replaced by the new mark. The entire \scheme'wcm' expression takes on \scheme'body-value'.

A \scheme'ccm' expression of the form \scheme|(ccm)| traverses the continuation accumulating a list of annotations ascending in age.

If the factorial function is defined by
\begin{schemedisplay}
(define (fac n)
  (if (zero? n)
      (begin
        (print (ccm))
        1)
      (wcm n (* n (fac (- n 1))))))
\end{schemedisplay}
then the expression \scheme|(fac 2)| evaluates as
\begin{schemedisplay}
(fac 2)
(if (zero? 2) ... (wcm 2 (* 2 (fac (- 2 1)))))
(wcm 2 (* 2 (fac (- 2 1))))
(wcm 2 (* 2 (fac 1)))
(wcm 2 (* 2 (if (zero? 1) ... (wcm 1 (* 1 (fac (- 1 1)))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac (- 1 1))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac 0)))))
(wcm 2 (* 2 (wcm 1 (* 1 (if (zero? 0) (begin (print (ccm)) 1) ...)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print (ccm)) 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print '(1 2)) 1)))))
'(1 2)
(wcm 2 (* 2 (wcm 1 (* 1 (begin 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 1))))
(wcm 2 (* 2 (wcm 1 1)))
(wcm 2 (* 2 1))
(wcm 2 2)
2
\end{schemedisplay}

Continuation marks respect tail-call optimization. Recall that in a language that is tail-call optimized, the continuation doesn't grow at the occurrence of a tail call as instead the previous execution context is subsumed by the new. Thus, with a tail-recursive definition of the factorial function as in
\begin{schemedisplay}
(define (fac n acc)
  (if (zero? n)
      (begin
        (print (ccm))
        acc)
      (wcm n (fac (- n 1) (* n acc)))))
\end{schemedisplay}
evaluation of \scheme|(fac 2)| proceeds as
\begin{schemedisplay}
(fac 2 1)
(if (zero? 2) ... (wcm 2 (fac (- 2 1) (* 2 1))))
(wcm 2 (fac (- 2 1) (* 2 1)))
(wcm 2 (fac 1 (* 2 1)))
(wcm 2 (fac 1 2))
(wcm 2 (if (zero? 1) ... (wcm 1 (fac (- 1 1) (* 1 2)))))
(wcm 2 (wcm 1 (fac (- 1 1) (* 1 2))))
(wcm 1 (fac (- 1 1) (* 1 2)))
(wcm 1 (fac 0 (* 1 2)))
(wcm 1 (fac 0 2))
(wcm 1 (if (zero? 0) (begin (print (ccm)) 2) ...))
(wcm 1 (begin (print (ccm)) 2))
(wcm 1 (begin (print '(1)) 2))
'(1)
(wcm 1 (begin 2))
(wcm 1 2)
2
\end{schemedisplay}
and the tail-call behavior is clear.

Language transformations must be meaningful: they must preserve meaning or provide it. Continuation marks have special meaning in the presence of tail-call optimization.
% uses of language transformation:
% meaning of one language in terms of another (desugaring)
% - reduce core code which simplifies implementations
% easier to reason/optimize

Language transformations are used for many reasons, but they he transformation must be meaningful: it must either preserve meaning or provide it.

Language transformations either provide meaning or preserve meaning.

Language transformation is useful for a variety of purposes. It can be used to define one language in terms of another, It can be used to give meaning to the source language in terms of the target language [cite something], provide a characterization more amenable to analysis or optimization. Language transformation can also be used to \emph{desugar} a language into a simpler core. This 
Transforming has the following benefits:
reduce core code (desugaring, simplifies implementations)
give meaning to constructs (semantically, as well as, say, macros)
local transformations - macros, for example
global transformations - compilers of all kinds, for example

talk about the common practice of analyzing an extension of the lambda calculus, and a subpractice of doing so via a transformation to the core.

While continuation marks have had significant treatment, they do not currently enjoy a transformation to the plain $\lambda$-calculus.

\section{Continuation Marks}

Continuation marks generalize stack inspection, allowing a bevy of features that rely on some form of it to be defined at the language level. This includes algebraic steppers \cite{clements2001modeling}, security policies \cite{clements2004tail}, and aspects \cite{tucker2003pointcuts}. By defining such tools at the language level, such tools are more robust, cheaper to port, more easily changed, etc.

Despite their profound utility, few languages offer continuation marks. Their inception lays in Racket \cite{plt-tr1} and they have been added experimentally to \emph{JavaScript} \cite{clements2008implementing}, but their earnest adoption by other languages has been nonexistent.

% transformation means that they can be compiled away and any higher order language can have them
% transformation also means that they do not need to be built into the language

% talk about composability of this transform to others

Racket offers desugaring facilities to the user via a powerful macro system. This requires and is limited to local transformations limited to expression boundaries.

A transformation-based compiler, such as a CPS compiler \cite{appel2007compiling}, effects a global transformation of the program. This effect discards original source or transforms it so radically that it is suitable only for the levels beneath the programmer's regular interaction.

\section{\cm}

We define an extension of the call-by-value \lc\ with facilities for continuation marks. To begin, we briefly formalize the definition of the call-by-value \lc which we refer to as \lv.

Terms $e$ in \lv\ are the familiar terms of the \lc, defined by
\begin{equation}
e=\app{e}{e}\,|\,v\,|\,x
\end{equation}
where 
\begin{equation}
v=\abs{x}{e}
\end{equation}
describes the values of the \lc.

The evaluation model of \lv\ requires a definition of evaluation contexts. We define evaluation contexts $E$ by
\begin{equation}
E=\app{E}{e}\,|\,\app{v}{E}\,|\,\hole
\end{equation}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The semantics of \lv\ are defined simply by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]
\end{align}
where $e[x\leftarrow v]$ denotes a capture-avoiding substitution of every free occurrence of $x$ in $e$ with $v$.

Because \cm\ is an extension of \lv, the definition of terms $e$ in \cm\ 
\begin{equation}
e=\wcm{e}{e}\,|\,\ccm\,|\,\app{e}{e}\,|\,v\,|\,x
\end{equation}
is identical to that of \lv\ with the addition of two forms for manipulating continuation marks: \scheme'wcm', short for \scheme'with-continuation-mark', which annotates the continuation with the evaluation of the given mark expression; and \scheme'ccm', short for \scheme'current-continuation-marks', which retrieves the current continuation marks.

The sole novelty of \cm\ above the plain \lc\ is the ability to annotate and observe the continuation. Our evaluation model of \cm, introduced by Pettyjohn et al. \cite{pettyjohn2005continuations}, utilizes the current evaluation context for that purpose. The mutually inductive valuation contexts $E$, $F$ are defined by
\begin{align}
E=\, &\wcm{v}{F}\,|\,F\\
F=\, &\app{E}{e}\,|\,\app{v}{E}\,|\,\wcm{E}{e}\,|\,\hole
\end{align}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The semantics of \cm\ are
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]\\
E[\wcm{v}{\wcm{v'}{e}}] &\rr E[\wcm{v'}{e}]\\
E[\wcm{v}{v'}]          &\rr E[v']\\
E[\ccm]                 &\rr E[\chi(E)]
\end{align}
where $\chi$ is defined by
\begin{equation}
\chi(E)=\chi'(E,\mathbf{nil})
\end{equation}
and where $\chi'$ is defined in turn by
\begin{align}
\chi'(\wcm{v}{F},vs) &= \chi'(F,\abs{z}{\app{\app{z}{v}}{vs}})\\
\chi'(\app{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\app{v}{E},vs) &= \chi'(E,vs)\\
\chi'(\wcm{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\hole,vs)      &= vs
\end{align}
Notice that $\chi'$ is defined in accumulator-passing style which has the effect of ordering the marks from most- to least-recently placed. The direct style formulation reverses this order. In the end, the ordering chosen is immaterial; we use this formulation to make the transform simpler.

\subsection{\cm\ Example}

\scheme|(wcm 4|

\section{Transformation}

A meaning-preserving transformation should commute with evaluation. By this, we mean that the following property should hold for programs $p\in\lambda_{cm}$.

\[
\begin{array}{ccc}
p & \cmrrs & v\\
\downarrow_\mathcal{C} & & \downarrow_\mathcal{C}\\
\C{p} & \lvrrs & \C{v}
\end{array}
\]

This diagram captures the property that a meaning-preserving transformation commutes with evaluation. More succinctly, 
\begin{equation}
\label{meaning-preservation-property}
p\cmrrs v\implies\C{p}\lvrrs\C{v}
\end{equation}

Our first approach was to use CPS because it treats all data and control flow uniformly [cite Sabry]. We passed an additional parameter (or two) in the spirit of double-barrelled continuations (but only in spirit). Our first attempt passed a pair as the second argument that needed to be deconstructed and constructed in every recursive definition. This was a lot of mindless manipulation that had little to do with the essence of the transform. In what took far too long a time, we realized the extent of this manipulation and finally confronted the subconscious aversion to passing \emph{two} arguments which we found was baseless.

Almost immediately after, we realized that CPS was wholly unnecessary and landed back where we started with a direct-style definition.


A comprehensive language transformation need only be defined over each syntactic form of the language. Thus, our full transformation definition will comprise transformation definitions for each of the five syntactic forms of \cm.

As variables, abstractions, and applications exist in the target language, we imagine that their transformation will be relatively straightforward. The essence of \cm\ is that programs within can apply information to and observe information about the context in which they are evaluated. The work of the transform is then to propagate contextual information to each expression, manipulating it appropriately as the context changes.

The treatment of \scheme'wcm' will require care as it is especially sensitive to evaluation order. Assuming termination for all constituent evaluations, consider
\begin{align*}
       &E[\wcm{e_0}{\wcm{e_1}{e_2}}]\\
\cmrrs &E[\wcm{v_0}{\wcm{e_1}{e_2}}]\\
\cmrrs &E[\wcm{v_0}{\wcm{v_1}{e_2}}]\\
\cmrr  &E[\wcm{v_1}{e_2}]\\
\cmrrs &E[\wcm{v_1}{v_2}]\\
\cmrr  &E[v_2]
\end{align*}
We will need to arrange arguments in such a way that the natural call-by-value evaluation order of \lv\ accomplishes correct evaluation order according to the semantics of \cm.

The treatment of \scheme'ccm' simply needs access to the evaluation of $\chi$ on the current context. As \lv\ lacks any facility to observe the context, the transformation needs to explicitly provide this information to each \scheme'ccm' expression. The $\chi$ metafunction is continuous in the sense that a small change in the prefix of the input effects only a small change in the prefix of the output, a consequence of its particular recursive definition. This fact means that it is possible to compute $\chi$ incrementally. The transform would then need to ensure that each expression had access to information about its own context.

Finally, we consider the preservation of proper tail-call behavior. Even though tail calls exist in \lv--indeed, they are prevalent--we cannot rely on their behavior to honor proper tail-call behavior through the transform. Thus, we would need to maintain information about the immediate context of the program: specifically, whether evaluation is occurring directly within the body of a \scheme'wcm' expression or not.

To accomplish each of these, the transform is defined in the spirit of CPS. Recall that in
CPS, every function receives an additional formal parameter and every call site receives a
corresponding argument. The definition of $\mathcal{C}$ takes this a step further under
which every function receives \emph{two} additional formal parameters and every call site
two additional arguments. As in CPS, the first parameter encapsulates the continuation or,
for our purposes, the evaluation context. The second encapsulates all contextual
information observable to the original \cm\ program.

\newtheorem{defn}{Definition}

\newenvironment{schemedefn}[1]{\begin{defn}$#1$}{\end{defn}}
\newenvironment{namedschemedefn}[2]{\begin{defn}\label{#1}$#2$}{\end{defn}}

\setspecialsymbol{TRUE}{$\mathbf{true}$}
\setspecialsymbol{FALSE}{$\mathbf{false}$}
\setspecialsymbol{PAIR}{$\mathbf{pair}$}
\setspecialsymbol{FST}{$\mathbf{fst}$}
\setspecialsymbol{SND}{$\mathbf{snd}$}
\setspecialsymbol{NIL}{$\mathbf{nil}$}

\newcommand{\true}{\mathbf{true}}
\newcommand{\false}{\mathbf{false}}
\newcommand{\nil}{\mathbf{nil}}
\newcommand{\pair}[2]{((\mathbf{pair}\,#1)\,#2)}
\newcommand{\eval}[1]{\overline{#1}}

\begin{defn}
$\true=\abs{x}{\abs{y}{x}}$
\end{defn}

\begin{defn}
$\false=\abs{x}{\abs{y}{y}}$
\end{defn}

\begin{defn}
$\mathbf{pair}=\abs{a}{\abs{b}{\abs{z}{\app{\app{z}{a}}{b}}}}$
\end{defn}

\begin{defn}
$\mathbf{fst}=\abs{p}{\app{p}{\true}}$
\end{defn}

\begin{defn}
$\mathbf{snd}=\abs{p}{\app{p}{\false}}$
\end{defn}

\begin{defn}
$\nil=\false$
\end{defn}

\begin{schemedefn}{\C{\app{e_0}{e_1}}}
\begin{schemedisplay}
(lambda (k)
   (lambda (f)
     (lambda (m)
       (((Ce_0
          (lambda (a)
            (((Ce_1
               (lambda (b)
                 ((((a b) k) f) m)))
              FALSE)
             m)))
         FALSE)
        m))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\C{\wcm{e_0}{e_1}}}
\begin{schemedisplay}
(lambda (k)
  (lambda (f)
    (lambda (m)
      (((Ce_0
         (lambda (n) ((lambda (k) 
                        (k (((m (lambda (x) x)) (lambda (z) z)) (lambda (z) z))))
                      (lambda (t) 
                        ((lambda (k) (k ((f C[(SND t)]) t)))
                         (lambda (r) 
                           (((Ce_1 k) TRUE) C[(PAIR v r)])))))))
        FALSE)
       m))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\C{\ccm}}
\begin{schemedisplay}
(lambda (k)
  (lambda (f)
    (lambda (m)
      (((m k) (lambda (z) z)) (lambda (z) z)))))
\end{schemedisplay}
\end{schemedefn}

\begin{defn}
$\C{v_0}=\C{\abs{x}{e'_0}}=\abs{k}{\abs{f}{\abs{m}{\app{k}{\abs{x}{\C{e'_0}}}}}}$
\end{defn}

\begin{defn}
$\C{x}=\abs{k}{\abs{f}{\abs{m}{\app{k}{x}}}}$
\end{defn}

\subsection{Example: Factorial}

For convenience, we will augment the base language with direct forms for expressing factorial. Define terms $e$ in \lv\ by
\begin{equation}
e=\app{e}{e}\,|\,(*\,e\,e)\,|\,\app{\mathrm{pred}}{e}\,|\,\app{\mathrm{zero?}}{e}\,|\,v\,|\,x
\end{equation}
and values $v$ by
\begin{equation}
v=\abs{x}{e}\,|\,\mathbb{N}
\end{equation}
.

We can express the factorial function by the following
\begin{schemedisplay}
(Y (lambda (f)
     (lambda (n)
       (((zero? n)
         1)
        (* n (f (pred n)))))))
\end{schemedisplay}

and with continuation marks by
\begin{schemedisplay}
(Y (lambda (f)
     (lambda (n)
       (((zero? n)
         (print (ccm) 1))
        (* n (wcm n (f (pred n))))))))
\end{schemedisplay}

\section{Testing}

A pragmatic approach to the discovery of a correct transformation involves consistent feedback and testing to validate candidate transforms. Testing is no substitute for proof, but, as Klein et al. \cite{klein2012run} show, proof is no substitute for testing. Lightweight mechanization is a fruitful middle ground between pencil-and-paper analysis and fully-mechanized formal proof. We use Redex \cite{findler2010redex}, a domain-specific language for exploring language semantics, to provide feedback, thoroughly exercise candidates, and perform exploratory analysis.

The correctness of the transform lies in the property that it commutes. In order to test for this property, we must construct evaluation models for the source language \cm\ and the target language \lv. Since \cm\ is an extension of \lv, many of its forms and semantics are inherited. Redex allows us to exploit this fact by defining a model for \lv\ first and then extending that model with the enhancements of \cm.

\setkeyword{define-language define-extended-language define-metafunction reduction-relation extend-reduction-relation define-metafunction/extension in-hole hole variable-not-otherwise-mentioned}
\setkeyword{wcm ccm}

\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{->}{$\to$}
\setspecialsymbol{-->}{$\rightarrow$}
\setspecialsymbol{betav}{$\beta$v}
\setconstant{error}
\setkeyword{chi chi_p}

\setspecialsymbol{lambdav}{$\lambda$v}
\setspecialsymbol{lambdav-rr}{$\lambda$v-rr}
\setspecialsymbol{lambdav-subst}{$\lambda$v-subst}

We first define the form of terms $e$, values $v$, and evaluation contexts $E$.

\begin{schemedisplay}
(define-language lambdav
  (e (e e) x v error)
  (x variable-not-otherwise-mentioned)
  (v (lambda (x) e) number)
  (E (E e) (v E) hole))
\end{schemedisplay}

We then define the reduction relation for \lv. It consists of five rules. The first rule captures the sole semantic rule of \lv; the remaining handle error conditions.

\begin{schemedisplay}
(define lambdav-rr
  (reduction-relation lambdav
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdav-subst x v e))
        "betav")
   (--> (in-hole E (number_1 v))
        (in-hole E error)
        "error: number in operator position")
   (--> (in-hole E x)
        (in-hole E error)
        "error: unbound identifier")
   (--> (in-hole E (error e))
        (in-hole E error)
        "error in operator")
   (--> (in-hole E (v error))
        (in-hole E error)
        "error in operand")))
\end{schemedisplay}

The reduction relation requires one metafunction to perform substitution. We omit any capture-avoidance facilities to keep the model simple and argue that it is unnecessary as we generate fresh variables in the transform.

\begin{schemedisplay}
(define-metafunction lambdav
  lambdav-subst : x v e -> e
  ;; 1. substitute in application
  [(lambdav-subst x_1 v_1 (e_1 e_2))
   ((lambdav-subst x_1 v_1 e_1) (lambdav-subst x_1 v_1 e_2))]
  ;; 2a. substitute in variable (same)
  [(lambdav-subst x_1 v_1 x_1)
   v_1]
  ;; 2b. substitute in variable (different)
  [(lambdav-subst x_1 v_1 x_2)
   x_2]
  ;; 3a. substitute in abstraction (bound)
  [(lambdav-subst x_1 v_1 (lambda (x_1) e_1))
   (lambda (x_1) e_1)]
  ;; 3b. substitute in abstraction (free)
  [(lambdav-subst x_1 v_1 (lambda (x_2) e_1))
   (lambda (x_2) (lambdav-subst x_1 v_1 e_1))]
  ;; 4. substitute in number
  [(lambdav-subst x_1 v_1 number_1)
   number_1]
  ;; 5. substitute in error
  [(lambdav-subst x_1 v_1 error)
   error])
\end{schemedisplay}




\setspecialsymbol{lambdacm}{$\lambda$cm}
\setspecialsymbol{lambdacm-rr}{$\lambda$cm-rr}
\setspecialsymbol{lambdacm-subst}{$\lambda$cm-subst}

We now define the forms of terms $e$, and evaluation contexts $E$ and $F$, inheriting definitions from \lv\ where appropriate.

\begin{schemedisplay}
(define-extended-language lambdacm lambdav
  (e .... (wcm e e) (ccm))
  (E (wcm v F) F)
  (F (E e) (v E) (wcm E e) hole))
\end{schemedisplay}

We extend the reduction relation of \lv. We begin by redefining application in terms of a substitution function aware of \cm. The following three definitions capture the remaining semantic rules of \cm. The remaining definitions handle error cases specific to \cm.

\begin{schemedisplay}
(define lambdacm-rr
  (extend-reduction-relation lambdav-rr lambdacm
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdacm-subst x v e))
        "betav")
   (--> (in-hole E (wcm v_1 (wcm v_2 e)))
        (in-hole E (wcm v_2 e))
        "wcm-collapse")
   (--> (in-hole E (wcm v_1 v_2))
        (in-hole E v_2)
        "wcm")
   (--> (in-hole E (ccm))
        (in-hole E (chi E))
        "chi")
   (--> (in-hole E (wcm error e))
        (in-hole E error)
        "error in wcm mark expression")
   (--> (in-hole E (wcm v error))
        (in-hole E error)
        "error in wcm body expression")))
\end{schemedisplay}

We extend the definition of substitution to accommodate the additional forms introduced by \cm.

\begin{schemedisplay}
(define-metafunction/extension lambdav-subst lambdacm
  lambdacm-subst : x v e -> e
  ;; 1. substitute in wcm form
  [(lambdacm-subst x_1 v_1 (wcm e_1 e_2))
   (wcm (lambdacm-subst x_1 v_1 e_1) (lambdacm-subst x_1 v_1 e_2))]
  ;; 2. substitute in ccm form
  [(lambdacm-subst x_1 v_1 (ccm))
   (ccm)])
\end{schemedisplay}

The definition of \scheme'chi' and \scheme'chi_p' mirror their definitions exactly.

\begin{schemedisplay}
(define-metafunction lambdacm
  chi : E -> v
  [(chi E) (chi_p E (lambda (x) (lambda (y) y)))])

(define-metafunction lambdacm
  chi_p : E v -> v
  [(chi_p hole v_ms)      v_ms]
  [(chi_p (E e) v_ms)     (chi_p E v_ms)]
  [(chi_p (v E) v_ms)     (chi_p E v_ms)]
  [(chi_p (wcm E e) v_ms) (chi_p E v_ms)]
  [(chi_p (wcm v E) v_ms) (chi_p E (lambda (p) ((p v) v_ms)))])
\end{schemedisplay}

We are now prepared to test various semantic properties of these two languages. Of course, we are interested in testing the commutativity of our transform. We observe that a mark-passing approach, much like a continuation-passing approach, abstracts terms and so requires a transformed term to be primed with an argument to initiate reduction. For this reason, we accompany each transform with an initialization function which primes a term appropriately for the corresponding transform.

We can test that the property described by equation \ref{meaning-preservation-property} holds for a given program \scheme'p' with 
\begin{schemedisplay}
(define (meaning-preserved? p)
  (alpha-eq? (transform (eval lambdacm p)) (eval lambdav (init (transform p)))))
\end{schemedisplay}
where \scheme'alpha-eq?' determines $\alpha$-equivalence between two \lc\ terms and \scheme'eval' is an alias for the Redex native \scheme'apply-reduction-relation*'.

Redex provides convenient functions to initiate random testing.

\begin{schemedisplay}
(redex-check lambdacm e (meaning-preserved? e))
\end{schemedisplay}

\scheme'redex-check' generates random terms according to the grammar of the given language (\scheme'lambdacm') and category (\scheme'e') in search of counterexamples to the predicate. 

\section{Proof}

\section{Continuation Marks in JavaScript}

% add stuff to language to express factorial
% define transformation of new constructs
% transform factorial function
% transliterate it to JS
% see continuation marks in JS

% we can add continuation marks to the compiler, but we can't deploy a virtual machine wherever we want. We need to leverage the existing, entrenched virtual machines. One approach would be to 

Given that we can express continuation marks in the \lc, we can see that the only thing necessary for continuation marks is first-class functions. JavaScript is a ubiquitous higher-order language that lacks continuation marks. Clements et al. experimentally added continuation marks to JavaScript by directly modifying Mozilla's Rhino implementation \cite{clements2008implementing}. This is a natural fit as the implementation is designed to optimize tail calls providing a venue in which the full semantics of continuation marks can be observed.

Many implementations do not optimize tail calls. We could modify these implementations to first optimize tail calls and then support continuation marks, but this does nothing to the existing, entrenched virtual machines in use today. For this reason, we define a superset of JavaScript with continuation marks and a transformation to base JavaScript. The transformation utilizes the tail-position flag and mark-passing style of the \lc\ transform.

functions receive two additional arguments
if a call is in tail position, pass that flag.
I don't know.



We transliterate

\section{Conclusion}

Continuation marks support a bevy of instrumentation tools and advanced language features in a generalized, portable way. Despite their demonstrated utility, they have not yet found their way into most languages. A verified characterization of continuation marks in a pure computational language provides implementors of higher-order languages a correct compiler for continuation marks.

Stack inspection is a common approach for instrumentation and dynamic 

Instrumentation tools abound, and stack inspection is a common method to in

Stack inspection is a common approach to natural method to obtain dynamic information, but typical implementation

We have provided and verified a correct transformation for continuation marks which, in effect, compiles them away.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}
