\documentclass{llncs}

\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{slatex}

\title{Instant Continuation Marks--Just Add $\lambda$}

\author{Kimball Germane \and Jay McCarthy}
\institute{Brigham Young University}

% Look at the many other papers on c marks to justify them (see mine for
% example). Talk about how your transformation is a compiler and right
% now no language but Racket has C-marks, so we could use this to get
% them in that language. For Racket though, now they don't need to be
% built in to the compiler if we don't want. In addition, it makes it
% easier to do a type system.

\setkeyword{wcm ccm with-continuation-mark current-continuation-marks}
\setkeyword{print fac zero?}

\newcommand{\cm}[0]{$\lambda_{cm}$}
\newcommand{\lv}[0]{$\lambda_v$}
\newcommand{\lc}[0]{$\lambda$-calculus}
\newcommand{\wcm}[2]{(\mathrm{wcm}\,#1\,#2)}
\newcommand{\ccm}[0]{(\mathrm{ccm})}
\newcommand{\app}[2]{(#1\,#2)}
\newcommand{\abs}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\hole}[0]{\bullet}
\newcommand{\rr}[0]{\rightarrow}
\newcommand{\lrrs}[0]{\rightarrow^{*}}
\newcommand{\lvrr}[0]{\rightarrow_v}
\newcommand{\lvrrs}[0]{\rightarrow_v^{*}}
\newcommand{\cmrr}[0]{\rightarrow_{cm}}
\newcommand{\cmrrs}[0]{\rightarrow_{cm}^{*}}
\newcommand{\C}[1]{\mathcal{C}[#1]}

\begin{document}

\maketitle

\begin{abstract}
Continuation marks are a programming language feature which generalizes stack inspection. Despite its usefulness, this feature has not been adopted by languages which rely on stack inspection, e.g., for dynamic security checks. One reason for this neglect may be that continuation marks do not yet enjoy a transformation to the plain $\lambda$-calculus which would allow higher-order languages to provide continuation marks at little cost.

We present direct and CPS-like transformations from the call-by-value $\lambda$-calculus augmented with continuation marks to the pure call-by-value $\lambda$-calculus. We discuss how such transformations simplify the construction of compilers which treat continuation marks correctly. We document the aide of Redex, a domain-specific language for exploring language semantics, in the discovery of correct transformations. Finally, we verify the transformations with the proof of a meaning-preservation theorem.
\end{abstract}

\section{Introduction}

% motivate continuation marks
% motivate continuation marks in more languages
% discuss why they are not in more languages
% discuss approaches to getting them in languages with pros/cons
% ...culminating in our approach in terms of lambda

Numerous programming language instruments rely on stack inspection to function. Statistical profilers sample the stack regularly to record active functions, algebraic steppers observe the stack to represent the evaluation context of an expression, and debuggers naturally require consistent access to the stack. Each of these relies on implementation-specific information and must be maintained as the instrumented language undergoes optimizations and ventures across platforms. This makes these tools brittle and increases the porting cost of the language ecosystem. Each of these examples would benefit from a generalized stack-inspection mechanism available within the instrumented language itself. If written in such an enhanced language, each instrument would be more robust, more easily modified, and would port for free.

Continuation marks \cite{clements2006portable} are a programming language feature which generalizes stack inpection. Not only do they dramatically simplify correct instrumentation \cite{clements2001modeling}, they have been used to allow inspection-based dynamic security checks in the presence of tail-call optimization \cite{clements2004tail} and to express aspect-oriented programming in higher-order languagues \cite{tucker2003pointcuts}.

Continuation marks originated in PLT Scheme (now Racket \cite{plt-tr1}). However, in spite of their usefulness, continuation marks have remained absent from programming languages at large. One reason for this is that retrofitting virtual machines to accommodate the level of stack inspection continuation marks must provide is expensive, especially when the virtual machines use the host stack for efficiency.

For example, the ubiquitous JavaScript is an ideal candidate for the addition of continuation marks. However, as the lingua franca of the web, it has numerous mature implementations which have been heavily optimized. To add continuation marks to JavaScript amounts to modifying each implementation upstream, to say nothing of amending the JavaScript standard. (Clements et al. successfully added continuation marks in Mozilla's Rhino compiler \cite{clements2008implementing}, but it remains a proof-of-concept.)

To avoid this roadblock, we instead take a macro-style approach; that is, we enhance the core language with facilities to manipulate continuation marks and desugar the enhanced language back to the core. To make our desugaring transformation portable to other languages, we define it over the \lc, the common core of most higher-order languages. With such a transformation, language semanticists do not need to reconcile the feature with other features in the language (provided they have already done so with $\lambda$) and their compiler writers do not need to worry about complicating their implementations (for the same reason).

We begin this paper exposing continuation marks further. We then present a core and enhanced language along with Redex models for each. We discuss the necessary properties for a meaningful transform.  We present two transformations of continuation marks--one direct and one CPS-like--to the call-by-value \lc. We then prove a meaning-preservation theorem.

\section{Continuation Marks}

Continuation marks allow the program to annotate and observe the stack (or continuation). This is accomplished via two surface-level syntactic forms in the language: \scheme'with-continuation-mark', abbreviated \scheme'wcm'; and \scheme'current-continuation-marks', abbreviated \scheme'ccm'.

A \scheme'wcm' expression of the form \scheme|(wcm mark-expr body-expr)| annotates the youngest portion of the continuation with \scheme'mark-value', the evaluation of \scheme'mark-expr', before evaluating \scheme'body-expr' to \scheme'body-value'. If an annotation, or \emph{mark}, already exists on the youngest portion, it is replaced by the new mark. The entire \scheme'wcm' expression takes on \scheme'body-value'.

A \scheme'ccm' expression of the form \scheme|(ccm)| traverses the continuation accumulating a list of annotations ascending in age.

If the factorial function is defined by
\begin{schemedisplay}
(define (fac n)
  (if (zero? n)
      (begin
        (print (ccm))
        1)
      (wcm n (* n (fac (- n 1))))))
\end{schemedisplay}
then the expression \scheme|(fac 2)| evaluates as
\begin{schemedisplay}
(fac 2)
(if (zero? 2) ... (wcm 2 (* 2 (fac (- 2 1)))))
(wcm 2 (* 2 (fac (- 2 1))))
(wcm 2 (* 2 (fac 1)))
(wcm 2 (* 2 (if (zero? 1) ... (wcm 1 (* 1 (fac (- 1 1)))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac (- 1 1))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac 0)))))
(wcm 2 (* 2 (wcm 1 (* 1 (if (zero? 0) (begin (print (ccm)) 1) ...)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print (ccm)) 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print '(1 2)) 1)))))
'(1 2)
(wcm 2 (* 2 (wcm 1 (* 1 (begin 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 1))))
(wcm 2 (* 2 (wcm 1 1)))
(wcm 2 (* 2 1))
(wcm 2 2)
2
\end{schemedisplay}

Continuation marks respect tail-call optimization. A tail call in a tail-call optimized language does not enlarge the continuation. Instead, the previous portion of the execution context is subsumed by the new. Conceptually, the continuation does not grow to accommodate new marks; if one is made, the previous is overwritten. Thus, with a tail-recursive definition of the factorial function as in
\begin{schemedisplay}
(define (fac n acc)
  (if (zero? n)
      (begin
        (print (ccm))
        acc)
      (wcm n (fac (- n 1) (* n acc)))))
\end{schemedisplay}
evaluation of \scheme|(fac 2)| proceeds as
\begin{schemedisplay}
(fac 2 1)
(if (zero? 2) ... (wcm 2 (fac (- 2 1) (* 2 1))))
(wcm 2 (fac (- 2 1) (* 2 1)))
(wcm 2 (fac 1 (* 2 1)))
(wcm 2 (fac 1 2))
(wcm 2 (if (zero? 1) ... (wcm 1 (fac (- 1 1) (* 1 2)))))
(wcm 2 (wcm 1 (fac (- 1 1) (* 1 2))))
(wcm 1 (fac (- 1 1) (* 1 2)))
(wcm 1 (fac 0 (* 1 2)))
(wcm 1 (fac 0 2))
(wcm 1 (if (zero? 0) (begin (print (ccm)) 2) ...))
(wcm 1 (begin (print (ccm)) 2))
(wcm 1 (begin (print '(1)) 2))
'(1)
(wcm 1 (begin 2))
(wcm 1 2)
2
\end{schemedisplay}
and the tail-call behavior is clear.



%Language transformations must be meaningful: they must preserve meaning or provide it. Continuation marks have special meaning in the presence of tail-call optimization.
% uses of language transformation:
% meaning of one language in terms of another (desugaring)
% - reduce core code which simplifies implementations
% easier to reason/optimize

%Language transformations are used for many reasons, but they he transformation must be meaningful: it must either preserve meaning or provide it.

%Language transformations either provide meaning or preserve meaning.

%Language transformation is useful for a variety of purposes. It can be used to define one language in terms of another, It can be used to give meaning to the source language in terms of the target language [cite something], provide a characterization more amenable to analysis or optimization. Language transformation can also be used to \emph{desugar} a language into a simpler core. This 
%Transforming has the following benefits:
%reduce core code (desugaring, simplifies implementations)
%give meaning to constructs (semantically, as well as, say, macros)
%local transformations - macros, for example
%global transformations - compilers of all kinds, for example

%talk about the common practice of analyzing an extension of the lambda calculus, and a subpractice of doing so via a transformation to the core.

%While continuation marks have had significant treatment, they do not currently enjoy a transformation to the plain $\lambda$-calculus.

%\section{Continuation Marks}

%Continuation marks generalize stack inspection, allowing a bevy of features that rely on some form of it to be defined at the language level. This includes algebraic steppers \cite{clements2001modeling}, security policies \cite{clements2004tail}, and aspects \cite{tucker2003pointcuts}. By defining such tools at the language level, such tools are more robust, cheaper to port, more easily changed, etc.

%Despite their profound utility, few languages offer continuation marks. Their inception lays in Racket \cite{plt-tr1} and they have been added experimentally to \emph{JavaScript} \cite{clements2008implementing}, but their earnest adoption by other languages has been nonexistent.

% transformation means that they can be compiled away and any higher order language can have them
% transformation also means that they do not need to be built into the language

% talk about composability of this transform to others

%Racket offers desugaring facilities to the user via a powerful macro system. This requires and is limited to local transformations limited to expression boundaries.

%A transformation-based compiler, such as a CPS compiler \cite{appel2007compiling}, effects a global transformation of the program. This effect discards original source or transforms it so radically that it is suitable only for the levels beneath the programmer's regular interaction.

\section{Language Core and Extension}

We begin by formally defining the core language the transformation produces and the extended language over which the transformation is defined.

\subsection{\lv}

The target language of the transformation, \lv, is simply the call-by-value \lc.

Terms $e$ in \lv\ are the familiar terms of the \lc, defined by
\begin{equation}
e=\app{e}{e}\,|\,v\,|\,x
\end{equation}
where 
\begin{equation}
v=\abs{x}{e}
\end{equation}
describes the values of the \lc.

The evaluation model of \lv\ requires a definition of evaluation contexts. We define evaluation contexts $E$ by
\begin{equation}
E=\app{E}{e}\,|\,\app{v}{E}\,|\,\hole
\end{equation}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The semantics of \lv\ are defined simply by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]
\end{align}
where $e[x\leftarrow v]$ denotes a capture-avoiding substitution of every free occurrence of $x$ in $e$ with $v$.

\subsection{\cm}

The source language of the transformation, \cm, is an extension of \lv\ with facilities for continuation marks.

Because \cm\ is an extension of \lv, the definition of terms $e$ in \cm\ 
\begin{equation}
e=\wcm{e}{e}\,|\,\ccm\,|\,\app{e}{e}\,|\,v\,|\,x
\end{equation}
is identical to that of \lv\ with the addition of two forms for manipulating continuation marks: \scheme'wcm', short for \scheme'with-continuation-mark', which annotates the continuation with the evaluation of the given mark expression; and \scheme'ccm', short for \scheme'current-continuation-marks', which retrieves the current continuation marks.

The sole novelty of \cm\ above the plain \lv\ is the ability to annotate and observe the continuation. Our evaluation model of \cm, given by Pettyjohn et al. \cite{pettyjohn2005continuations}, utilizes the current evaluation context for that purpose. The mutually inductive valuation contexts $E$, $F$ are defined by
\begin{align}
E=\, &\wcm{v}{F}\,|\,F\\
F=\, &\app{E}{e}\,|\,\app{v}{E}\,|\,\wcm{E}{e}\,|\,\hole
\end{align}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The semantics of \cm\ are
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]\label{reduction}\\
E[\wcm{v}{\wcm{v'}{e}}] &\rr E[\wcm{v'}{e}]\label{tail-enforce}\\
E[\wcm{v}{v'}]          &\rr E[v']\label{wcm-body}\\
E[\ccm]                 &\rr E[\chi(E)]\label{ccm-in-context}
\end{align}
where $\chi$ is defined by
\begin{equation}
\chi(E)=\chi'(E,\mathbf{nil})
\end{equation}
and $\chi'$ is defined in turn by
\begin{align}
\chi'(\wcm{v}{F},vs) &= \chi'(F,\abs{z}{\app{\app{z}{v}}{vs}})\\
\chi'(\app{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\app{v}{E},vs) &= \chi'(E,vs)\\
\chi'(\wcm{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\hole,vs)      &= vs
\end{align}

As an extension of \lv, \cm\ inherits rule \ref{reduction} directly. Rule \ref{tail-enforce} expresses the tail-call behavior of \cm\ in that a new mark made in tail position overwrites the previous mark. Rule \ref{wcm-body} defines the value of a \scheme'wcm' expression to take on the value of the body. Finally, rule \ref{ccm-in-context} defines the value of a \scheme'ccm' expression in terms of its context via the metafunction $\chi$. The value of the function is a list of the current continuation marks.

Notice that $\chi'$ is defined in accumulator-passing style which has the effect of ordering the marks from most- to least-recently placed. The direct style formulation reverses this order. In the end, the ordering chosen is immaterial; we use this formulation to make the transform simpler.

\section{Transformation}

Language transformations must be meaningful: they must preserve meaning or provide it. As transformations, desugarings put the meaning of one construct in terms of another. If the meaning of the former was defined only informally, the desugaring offers a new definition as formal as the definition of the latter. In this way, desugarings offer a convenient way to provide meaning to a construct and avoid enlarging the language. If, however, the sugared language already has a formal meaning, the desugaring must preserve it. This will be made more precise shortly.

The transformation $\mathcal{C}$ is defined over each syntactic form of \cm. In order to preserve the meaning of \cm, $\mathcal{C}$ must commute with evaluation. More precisely, the following property should hold for programs $p\in\lambda_{cm}$:
\[
\begin{array}{ccc}
p & \cmrrs & v\\
\downarrow_\mathcal{C} & & \downarrow_\mathcal{C}\\
\C{p} & \lvrrs & \C{v}
\end{array}
\]
or, succinctly,
\begin{equation}
\label{meaning-preservation-property}
p\cmrrs v\implies\C{p}\lvrrs\C{v}
\end{equation}

%Our first approach was to use CPS because it treats all data and control flow uniformly [cite Sabry]. We passed an additional parameter (or two) in the spirit of double-barrelled continuations (but only in spirit). Our first attempt passed a pair as the second argument that needed to be deconstructed and constructed in every recursive definition. This was a lot of mindless manipulation that had little to do with the essence of the transform. In what took far too long a time, we realized the extent of this manipulation and finally confronted the subconscious aversion to passing \emph{two} arguments which we found was baseless.

%Almost immediately after, we realized that CPS was wholly unnecessary and landed back where we started with a direct-style definition.


%A comprehensive language transformation need only be defined over each syntactic form of the language. Thus, our full transformation definition will comprise transformation definitions for each of the five syntactic forms of \cm.

As variables, abstractions, and applications exist in the target language, their transformation is relatively straightforward. The essence of \cm\ is that programs can apply information to and observe information about the context in which they are evaluated. This characterization makes the work of the transform clear: to propagate contextual information to each expression, manipulating it appropriately as the context changes.

The treatment of \scheme'wcm' will require care as it is especially sensitive to evaluation order. Assuming termination for all constituent evaluations, consider
\begin{align*}
       &E[\wcm{e_0}{\wcm{e_1}{e_2}}]\\
\cmrrs &E[\wcm{v_0}{\wcm{e_1}{e_2}}]\\
\cmrrs &E[\wcm{v_0}{\wcm{v_1}{e_2}}]\\
\cmrr  &E[\wcm{v_1}{e_2}]\\
\cmrrs &E[\wcm{v_1}{v_2}]\\
\cmrr  &E[v_2]
\end{align*}
We will need to arrange arguments in such a way that the natural call-by-value evaluation order of \lv\ accomplishes correct evaluation order according to the semantics of \cm.

The treatment of \scheme'ccm' simply needs access to the evaluation of $\chi$ on the current context. As \lv\ lacks any facility to observe the context, the transformation explicitly provides this information to each \scheme'ccm' expression. The $\chi$ metafunction is continuous in the sense that a small change in the prefix of the input effects only a small change in the prefix of the output, a consequence of its particular recursive definition. This fact means that it is possible to compute $\chi$ incrementally. The transform then ensures that each expression had access to information about its own context.

Finally, we address the preservation of proper tail-call behavior. Even though tail calls exist in \lv--indeed, they are prevalent--their behavior does not honor proper tail-call behavior through the transform. Thus, we maintain information about the immediate context of the program: specifically, whether evaluation is occurring directly within the body of a \scheme'wcm' expression.

All together, the transformation adds three arguments to every term $e$: the continuation $k$ representative of the current context $E$; a flag $f$ encoding whether evaluation is occurring with the body of a \scheme'wcm' expression; and the transformed value $m$ of $\chi$ for the current context $\C{\chi(E)}$.

The formal definition of $\mathcal{C}$ follows.

\newenvironment{schemedefn}[1]{\begin{definition}$#1$}{\end{definition}}
\newenvironment{namedschemedefn}[2]{\begin{definition}\label{#1}$#2$}{\end{definition}}

\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{e_0}{$e_0$}
\setspecialsymbol{e_0p}{$e'_0$}
\setspecialsymbol{Ce_0}{$\C{e_0}$}
\setspecialsymbol{Ce_0p}{$\C{e'_0}$}
\setspecialsymbol{e_1}{$e_1$}
\setspecialsymbol{Ce_1}{$\C{e_1}$}
\setspecialsymbol{Ce_1p}{$\C{e'_1}$}
\setspecialsymbol{Cv}{$\C{v}$}
\setspecialsymbol{v_0}{$v_0$}
\setspecialsymbol{Cv_0}{$\C{v_0}$}
\setspecialsymbol{Cv_0p}{$\C{v'_0}$}
\setspecialsymbol{Cpv_0}{$\Cp{v_0}$}
\setspecialsymbol{Cpv_1}{$\Cp{v_1}$}
\setspecialsymbol{v_1}{$v_1$}
\setspecialsymbol{T}{$\mathcal{A}$}
\setspecialsymbol{C}{$\mathcal{C}$}
\setspecialsymbol{Cp}{$\mathcal{C}'$}
\setspecialsymbol{hole}{$\hole$}
\setspecialsymbol{bottom}{$\perp$}
\setspecialsymbol{Ce_0p_x_Cpv_1}{$\C{e'_0}[x\leftarrow\Cp{v_1}]$}
\setspecialsymbol{e_0p_x_v_1}{$e'_0[x\leftarrow v_1]$}
\setspecialsymbol{Cz}{$\C{z}$}
\setspecialsymbol{CE}{$\C{E}$}
\setspecialsymbol{xiE}{$\xi(E)$}
\setspecialsymbol{chiE}{$\chi(E)$}
\setspecialsymbol{CchiE}{$\C{\chi(E)}$}

\setspecialsymbol{TRUE}{$\mathbf{true}$}
\setspecialsymbol{FALSE}{$\mathbf{false}$}
\setspecialsymbol{PAIR}{$\mathbf{pair}$}
\setspecialsymbol{FST}{$\mathbf{fst}$}
\setspecialsymbol{SND}{$\mathbf{snd}$}
\setspecialsymbol{NIL}{$\mathbf{nil}$}

\newcommand{\true}{\mathbf{true}}
\newcommand{\false}{\mathbf{false}}
\newcommand{\nil}{\mathbf{nil}}
\newcommand{\pair}[2]{((\mathbf{pair}\,#1)\,#2)}
\newcommand{\eval}[1]{\overline{#1}}

\subsection{Useful Shorthand}

We first define a useful shorthand.

\begin{definition}
$\true=\abs{x}{\abs{y}{x}}$
\end{definition}

\begin{definition}
$\false=\abs{x}{\abs{y}{y}}$
\end{definition}

\begin{definition}
$\mathbf{pair}=\abs{a}{\abs{b}{\abs{z}{\app{\app{z}{a}}{b}}}}$
\end{definition}

\begin{definition}
$\mathbf{fst}=\abs{p}{\app{p}{\true}}$
\end{definition}

\begin{definition}
$\mathbf{snd}=\abs{p}{\app{p}{\false}}$
\end{definition}

\begin{definition}
$\nil=\false$
\end{definition}

\subsection{Definition of $\mathcal{C}$}

The definition of $\mathcal{C}$ over the five syntactic forms of \cm\ follows.

\begin{schemedefn}{\C{\app{e_0}{e_1}}}
\begin{schemedisplay}
(lambda (k)
   (lambda (f)
     (lambda (m)
       (((Ce_0
          (lambda (a)
            (((Ce_1
               (lambda (b)
                 ((((a b) k) f) m)))
              FALSE)
             m)))
         FALSE)
        m))))
\end{schemedisplay}
\end{schemedefn}

The evaluation of operator and operand in an application enlarges the continuation, so marks made within said evaluation will not interfere with pre-existent marks, and this is reflected by the $\false$ flag passed to each. Once the arguments are evaluated, the new context is unnecessary and discarded. The application itself inherits the flag of the original context.

\begin{schemedefn}{\C{\wcm{e_0}{e_1}}}
\begin{schemedisplay}
(lambda (k)
  (lambda (f)
    (lambda (m)
      (((Ce_0
         (lambda (n) ((lambda (k) 
                        (k (((m (lambda (x) x)) (lambda (z) z)) (lambda (z) z))))
                      (lambda (t) 
                        ((lambda (k) (k ((f C[(SND t)]) t)))
                         (lambda (r) 
                           (((Ce_1 k) TRUE) C[(PAIR v r)])))))))
        FALSE)
       m))))
\end{schemedisplay}
\end{schemedefn}

The definition over \scheme'wcm' expressions is the only one to make explicit use of the value of the flag. Following the evaluation of the mark expression, rule \ref{tail-enforce} is applied, if necessary. The continuity of $\chi$ allows us to construct $\chi(E''[\wcm{v_0}{e_1}])$ from $\chi(E)$ where 

\begin{equation}
E''=\begin{cases}
E' &\text{if $E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}\\
E &\text{otherwise}
\end{cases}
\end{equation}

\begin{schemedefn}{\C{\ccm}}
\begin{schemedisplay}
(lambda (k)
  (lambda (f)
    (lambda (m)
      (((m k) (lambda (z) z)) (lambda (z) z)))))
\end{schemedisplay}
\end{schemedefn}

The simplicity of the definition over \scheme`ccm` expressions offsets the work performed by the other definitions: it simply returns the list passed in.

\begin{definition}
$\C{v_0}=\C{\abs{x}{e'_0}}=\abs{k}{\abs{f}{\abs{m}{\app{k}{\abs{x}{\C{e'_0}}}}}}$
\end{definition}

\begin{definition}
$\C{x}=\abs{k}{\abs{f}{\abs{m}{\app{k}{x}}}}$
\end{definition}

%\subsection{Example: Factorial}

%For convenience, we will augment the base language with direct forms for expressing factorial. Define terms $e$ in \lv\ by
%\begin{equation}
%e=\app{e}{e}\,|\,(*\,e\,e)\,|\,\app{\mathrm{pred}}{e}\,|\,\app{\mathrm{zero?}}{e}\,|\,v\,|\,x
%\end{equation}
%and values $v$ by
%\begin{equation}
%v=\abs{x}{e}\,|\,\mathbb{N}
%\end{equation}
%.

%We can express the factorial function by the following
%\begin{schemedisplay}
%(Y (lambda (f)
%     (lambda (n)
%       (((zero? n)
%         1)
%        (* n (f (pred n)))))))
%\end{schemedisplay}

%and with continuation marks by
%\begin{schemedisplay}
%(Y (lambda (f)
%     (lambda (n)
%       (((zero? n)
%         (print (ccm) 1))
%        (* n (wcm n (f (pred n))))))))
%\end{schemedisplay}

\section{Testing}

A pragmatic approach to the discovery of a correct transformation involves consistent feedback and testing to validate candidate transforms. Testing is no substitute for proof, but, as Klein et al. \cite{klein2012run} show, proof is no substitute for testing. Lightweight mechanization is a fruitful middle ground between pencil-and-paper analysis and fully-mechanized formal proof. We use Redex \cite{findler2010redex}, a domain-specific language for exploring language semantics, to provide feedback, thoroughly exercise candidates, and perform exploratory analysis.

The correctness of the transform lies in the property that it commutes. In order to test for this property, we must construct evaluation models for the source language \cm\ and the target language \lv. Since \cm\ is an extension of \lv, many of its forms and semantics are inherited. Redex allows us to exploit this fact by defining a model for \lv\ first and then extending that model with the enhancements of \cm.

\setkeyword{define-language define-extended-language define-metafunction reduction-relation extend-reduction-relation define-metafunction/extension in-hole hole variable-not-otherwise-mentioned}
\setkeyword{wcm ccm}

\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{->}{$\to$}
\setspecialsymbol{-->}{$\rightarrow$}
\setspecialsymbol{betav}{$\beta$v}
\setconstant{error}
\setkeyword{chi chi_p number apply-reduction-relation*}

\setspecialsymbol{lambdav}{$\lambda$v}
\setspecialsymbol{lambdav-rr}{$\lambda$v-rr}
\setspecialsymbol{lambdav-subst}{$\lambda$v-subst}

We first define the form of terms $e$, values $v$, and evaluation contexts $E$.

\begin{schemedisplay}
(define-language lambdav
  (e (e e) x v error)
  (x variable-not-otherwise-mentioned)
  (v (lambda (x) e) number)
  (E (E e) (v E) hole))
\end{schemedisplay}

We then define the reduction relation for \lv. It consists of five rules. The first rule captures the sole semantic rule of \lv; the remaining handle error conditions.

\begin{schemedisplay}
(define lambdav-rr
  (reduction-relation lambdav
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdav-subst x v e))
        "betav")
   (--> (in-hole E (number_1 v))
        (in-hole E error)
        "error: number in operator position")
   (--> (in-hole E x)
        (in-hole E error)
        "error: unbound identifier")
   (--> (in-hole E (error e))
        (in-hole E error)
        "error in operator")
   (--> (in-hole E (v error))
        (in-hole E error)
        "error in operand")))
\end{schemedisplay}

The reduction relation requires one metafunction to perform substitution. We omit any capture-avoidance facilities to keep the model simple and argue that it is unnecessary as we generate fresh variables in the transform.

\begin{schemedisplay}
(define-metafunction lambdav
  lambdav-subst : x v e -> e
  ;; 1. substitute in application
  [(lambdav-subst x_1 v_1 (e_1 e_2))
   ((lambdav-subst x_1 v_1 e_1) (lambdav-subst x_1 v_1 e_2))]
  ;; 2a. substitute in variable (same)
  [(lambdav-subst x_1 v_1 x_1)
   v_1]
  ;; 2b. substitute in variable (different)
  [(lambdav-subst x_1 v_1 x_2)
   x_2]
  ;; 3a. substitute in abstraction (bound)
  [(lambdav-subst x_1 v_1 (lambda (x_1) e_1))
   (lambda (x_1) e_1)]
  ;; 3b. substitute in abstraction (free)
  [(lambdav-subst x_1 v_1 (lambda (x_2) e_1))
   (lambda (x_2) (lambdav-subst x_1 v_1 e_1))]
  ;; 4. substitute in number
  [(lambdav-subst x_1 v_1 number_1)
   number_1]
  ;; 5. substitute in error
  [(lambdav-subst x_1 v_1 error)
   error])
\end{schemedisplay}




\setspecialsymbol{lambdacm}{$\lambda$cm}
\setspecialsymbol{lambdacm-rr}{$\lambda$cm-rr}
\setspecialsymbol{lambdacm-subst}{$\lambda$cm-subst}

We now define the forms of terms $e$, and evaluation contexts $E$ and $F$, inheriting definitions from \lv\ where appropriate.

\begin{schemedisplay}
(define-extended-language lambdacm lambdav
  (e .... (wcm e e) (ccm))
  (E (wcm v F) F)
  (F (E e) (v E) (wcm E e) hole))
\end{schemedisplay}

We extend the reduction relation of \lv. We begin by redefining application in terms of a substitution function aware of \cm. The following three definitions capture the remaining semantic rules of \cm. The remaining definitions handle error cases specific to \cm.

\begin{schemedisplay}
(define lambdacm-rr
  (extend-reduction-relation lambdav-rr lambdacm
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdacm-subst x v e))
        "betav")
   (--> (in-hole E (wcm v_1 (wcm v_2 e)))
        (in-hole E (wcm v_2 e))
        "wcm-collapse")
   (--> (in-hole E (wcm v_1 v_2))
        (in-hole E v_2)
        "wcm")
   (--> (in-hole E (ccm))
        (in-hole E (chi E))
        "chi")
   (--> (in-hole E (wcm error e))
        (in-hole E error)
        "error in wcm mark expression")
   (--> (in-hole E (wcm v error))
        (in-hole E error)
        "error in wcm body expression")))
\end{schemedisplay}

We extend the definition of substitution to accommodate the additional forms introduced by \cm.

\begin{schemedisplay}
(define-metafunction/extension lambdav-subst lambdacm
  lambdacm-subst : x v e -> e
  ;; 1. substitute in wcm form
  [(lambdacm-subst x_1 v_1 (wcm e_1 e_2))
   (wcm (lambdacm-subst x_1 v_1 e_1) (lambdacm-subst x_1 v_1 e_2))]
  ;; 2. substitute in ccm form
  [(lambdacm-subst x_1 v_1 (ccm))
   (ccm)])
\end{schemedisplay}

The definition of \scheme'chi' and \scheme'chi_p' mirror their definitions exactly.

\begin{schemedisplay}
(define-metafunction lambdacm
  chi : E -> v
  [(chi E) (chi_p E (lambda (x) (lambda (y) y)))])

(define-metafunction lambdacm
  chi_p : E v -> v
  [(chi_p hole v_ms)      v_ms]
  [(chi_p (E e) v_ms)     (chi_p E v_ms)]
  [(chi_p (v E) v_ms)     (chi_p E v_ms)]
  [(chi_p (wcm E e) v_ms) (chi_p E v_ms)]
  [(chi_p (wcm v E) v_ms) (chi_p E (lambda (p) ((p v) v_ms)))])
\end{schemedisplay}

We are now prepared to test various semantic properties of these two languages. Of course, we are interested in testing the commutativity of our transform. We observe that a mark-passing approach, much like a continuation-passing approach, abstracts terms and so requires a transformed term to be primed with an argument to initiate reduction. For this reason, we accompany each transform with an initialization function which primes a term appropriately for the corresponding transform.

\setkeyword{meaning-preserved? alpha-eq? transform eval init redex-check}

We can test that the property described by equation \ref{meaning-preservation-property} holds for a given program \scheme'p' with 
\begin{schemedisplay}
(define (meaning-preserved? p)
  (alpha-eq? (transform (eval lambdacm p)) (eval lambdav (init (transform p)))))
\end{schemedisplay}
where \scheme'alpha-eq?' determines $\alpha$-equivalence between two \lc\ terms and \scheme'eval' is an alias for the Redex native \scheme'apply-reduction-relation*'.

Redex provides convenient functions to initiate random testing.

\begin{schemedisplay}
(redex-check lambdacm e (meaning-preserved? e))
\end{schemedisplay}

\scheme'redex-check' generates random terms according to the grammar of the given language (\scheme'lambdacm') and category (\scheme'e') in search of counterexamples to the predicate. 

\section{Proof}

\begin{definition}
\[
\mathrm{eval}_{cm}(p)=\begin{cases}
v     &\text{if $p\cmrrs v$}\\
\perp &\text{if $p\cmrrs\cdots$}
\end{cases}
\]
\end{definition}

\begin{definition}
\[
\mathrm{eval}_{v}(p)=\begin{cases}
v     &\text{if $p\lvrrs v$}\\
\perp &\text{if $p\lvrrs\cdots$}
\end{cases}
\]
\end{definition}

\newtheorem{maintheorem}{Correctness of $\mathcal{C}$}
\begin{maintheorem}
For all programs $p\in\lambda_{cm}$, $\C{\mathrm{eval}_{cm}(p)}=\mathrm{eval}_{v}(\C{p})$.
\end{maintheorem}

\section{Back to JavaScript}

With a correct transformation of continuation marks defined over the \lc, it requires little to add continuation marks to an eager, higher-order language such as JavaScript.

We add two keywords to manipulate continuation marks: the familiar \texttt{wcm} and \texttt{ccm}. We chose block syntax for \texttt{wcm} to convey that it is a special form, like a conditional, instead of a function-like interface. A lone \texttt{ccm} evaluates to the current continuation marks.

Factorial in this JavaScript extension can be implemented like the following:
\begin{verbatim}
var fac = function( n ) {
    if( n == 0 ) {
        console.log( ccm );
        return 1;
    }
    else {
        return wcm { n }
                   { n * fac( n - 1 ) };
    }
}
\end{verbatim}

A transformation of this function desugars these constructs into valid JavaScript.
\begin{verbatim}
var fac = function( f, m ) {
    return function( n ) {
        if( n == 0 ) {
            console.log( (function( f, m ) { return m; })( false, m ) );
            return 1;
        }
        else {
            return (function( f, m ) {
                return (function( v ) {
                    return n * fac( false, [ v ].concat( f ? m.slice( 1 ) : m ) )( n - 1 );
                })( n );
            })( f, m );
        }
    }
}
\end{verbatim} 

\section{Conclusion}

Continuation marks support a bevy of instrumentation tools and advanced language features in a generalized, portable way. Despite their demonstrated utility, they have not yet found their way into most languages. A verified characterization of continuation marks in a pure computational language provides implementors of higher-order languages a correct compiler for continuation marks.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}
