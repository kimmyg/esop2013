\documentclass{llncs}

\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{slatex}

\title{Instant Continuation Marks--Just Add $\lambda$}

\author{Kimball Germane \and Jay McCarthy}
\institute{Brigham Young University}

% Look at the many other papers on c marks to justify them (see mine for
% example). Talk about how your transformation is a compiler and right
% now no language but Racket has C-marks, so we could use this to get
% them in that language. For Racket though, now they don't need to be
% built in to the compiler if we don't want. In addition, it makes it
% easier to do a type system.

\setkeyword{wcm ccm with-continuation-mark current-continuation-marks}
\setkeyword{print fac zero?}

\newcommand{\cm}[0]{$\lambda_{cm}$}
\newcommand{\lv}[0]{$\lambda_v$}
\newcommand{\lc}[0]{$\lambda$-calculus}
\newcommand{\wcm}[2]{(\mathrm{wcm}\,#1\,#2)}
\newcommand{\ccm}[0]{(\mathrm{ccm})}
\newcommand{\app}[2]{(#1\,#2)}
\newcommand{\abs}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\hole}[0]{\bullet}
\newcommand{\rr}[0]{\rightarrow}
\newcommand{\lrrs}[0]{\rightarrow^{*}}
\newcommand{\lvrr}[0]{\rightarrow_v}
\newcommand{\lvrrs}[0]{\rightarrow_v^{*}}
\newcommand{\cmrr}[0]{\rightarrow_{cm}}
\newcommand{\cmrrs}[0]{\rightarrow_{cm}^{*}}
\newcommand{\C}[1]{\mathcal{C}[#1]}

\begin{document}

\maketitle

\begin{abstract}
Continuation marks are a programming language feature which generalizes stack inspection. Despite its usefulness, this feature has not been adopted by languages which rely on stack inspection, e.g., for dynamic security checks. One reason for this neglect may be that continuation marks do not yet enjoy a transformation to the plain $\lambda$-calculus which would allow higher-order languages to provide continuation marks at little cost.

We present direct and CPS-like transformations from the call-by-value $\lambda$-calculus augmented with continuation marks to the pure call-by-value $\lambda$-calculus. We discuss how such transformations simplify the construction of compilers which treat continuation marks correctly. We document the aide of Redex, a domain-specific language for exploring language semantics, in the discovery of correct transformations. Finally, we verify the transformations with the proof of a meaning-preservation theorem.
\end{abstract}

\section{Introduction}

% motivate continuation marks
% motivate continuation marks in more languages
% discuss why they are not in more languages
% discuss approaches to getting them in languages with pros/cons
% ...culminating in our approach in terms of lambda

Numerous programming language instruments rely on stack inspection to function. Statistical profilers sample the stack regularly to record active functions, algebraic steppers observe the stack to represent the evaluation context of an expression, and debuggers naturally require consistent access to the stack. In each of these scenarios, the instrument relies on implementation-specific information and must be maintained as the instrumented language undergoes optimizations and ventures across platforms. This makes these instruments brittle and increases the porting cost of the language ecosystem. Each would benefit from a generalized stack-inspection mechanism available within the instrumented language itself. If written in such an enhanced language, each instrument would be more robust, more easily modified, and would port for free.

Continuation marks \cite{clements2006portable} are a programming language feature which generalizes stack inpection. Not only do they dramatically simplify correct instrumentation \cite{clements2001modeling}, they have been used to allow inspection-based dynamic security checks in the presence of tail-call optimization \cite{clements2004tail} and to express aspect-oriented programming in higher-order languagues \cite{tucker2003pointcuts}.

Continuation marks originated in PLT Scheme (now Racket \cite{plt-tr1}). However, in spite of their usefulness, continuation marks have remained absent from programming languages at large. One reason for this is that retrofitting virtual machines to accommodate the level of stack inspection continuation marks must provide is expensive, especially when the virtual machines use the host stack for efficiency.

For example, the ubiquitous JavaScript is an ideal candidate for the addition of continuation marks. However, as the lingua franca of the web, it has numerous mature implementations which have been heavily optimized. To add continuation marks to JavaScript amounts to modifying each implementation upstream, to say nothing of amending the JavaScript standard. (Clements et al. successfully added continuation marks in Mozilla's Rhino compiler \cite{clements2008implementing}, but it remains a proof-of-concept.)

To avoid this roadblock, we instead take a macro-style approach; that is, we enhance the core language with facilities to manipulate continuation marks and desugar the enhanced language back to the core. To make our desugaring transformation portable to other languages, we define it over the \lc, the common core of most higher-order languages. With such a transformation, language semanticists do not need to reconcile the feature with other features in the language (provided they have already done so with $\lambda$) and their compiler writers do not need to worry about complicating their implementations (for the same reason).

We begin by further explaining continuation marks. We then formalize them via the introduction of a core and enhanced language with Redex models for each. We discuss the necessary properties for a meaningful transform.  We present two transformations of continuation marks--one direct and one CPS-like--to the call-by-value \lc. We then prove a meaning-preservation theorem.

\section{Continuation Marks}

Continuation marks allow the program to annotate and observe the stack (or continuation). This is accomplished via two surface-level syntactic forms in the language: \scheme'with-continuation-mark', abbreviated \scheme'wcm'; and \scheme'current-continuation-marks', abbreviated \scheme'ccm'.

A \scheme'wcm' expression of the form \scheme|(wcm mark-expr body-expr)| annotates the youngest portion of the continuation with \scheme'mark-value', the evaluation of \scheme'mark-expr', before evaluating \scheme'body-expr' to \scheme'body-value'. If an annotation, or \emph{mark}, already exists on the youngest portion, it is replaced by the new mark. This newly-added mark is available within \scheme'body-expr' via \scheme'ccm' during its evaluation. Once complete, the entire \scheme'wcm' expression takes on \scheme'body-value'.

A \scheme'ccm' expression of the form \scheme|(ccm)| traverses the continuation accumulating a list of annotations ascending in age.

\subsection{Example}

The traditional, properly-recursive factorial function can be expressed with continuation marks as follows:
\begin{schemedisplay}
(define (fac n)
  (if (zero? n)
      (begin
        (print (ccm))
        1)
      (wcm n (* n (fac (- n 1))))))
\end{schemedisplay}
In this definition, a multiplication pends following the recursive call, so the continuation grows with each.

The evaluation of the factorial of 2, expressed by \scheme|(fac 2)|, proceeds as
\begin{schemedisplay}
(fac 2)
(if (zero? 2) ... (wcm 2 (* 2 (fac (- 2 1)))))
(wcm 2 (* 2 (fac (- 2 1))))
(wcm 2 (* 2 (fac 1)))
(wcm 2 (* 2 (if (zero? 1) ... (wcm 1 (* 1 (fac (- 1 1)))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac (- 1 1))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac 0)))))
(wcm 2 (* 2 (wcm 1 (* 1 (if (zero? 0) (begin (print (ccm)) 1) ...)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print (ccm)) 1)))))
\end{schemedisplay}
At this point, the term \scheme|(ccm)| is evaluated. This happens, in effect, by walking the continuation and building a list of the current continuation marks which appear in the \scheme'mark-value' position of a \scheme'wcm' term. In this example, \scheme|(ccm)| evaluates to \scheme|'(1 2)|. Evaluation continues as
\begin{schemedisplay}
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print '(1 2)) 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 1))))
(wcm 2 (* 2 (wcm 1 1)))
(wcm 2 (* 2 1))
(wcm 2 2)
2
\end{schemedisplay}
The visible effect of the call is
\begin{verbatim}
> (fac 2)
(1 2)
2
\end{verbatim}

In a tail-call optimized language, a call made in tail position does not enlarge the continuation. Instead, the portion of the evaluation context dedicated to the calling function is repurposed for the called function. Continuation marks are also subject to this optimization; if the continuation is marked in tail position, the previous mark there is replaced, if it exists.

This behavior is apparent in the tail-recursive definition of the factorial function, which follows.
\begin{schemedisplay}
(define (fac n acc)
  (if (zero? n)
      (begin
        (print (ccm))
        acc)
      (wcm n (fac (- n 1) (* n acc)))))
\end{schemedisplay}
In this definition, the multiplication is performed before the recursive call and an accumulated value is passed. With no pending computation, the evaluation context devoted to this function is no longer necessary, and is subsumed by the continuation mark directive.

The evaluation of the factorial of 2, here expressed by \scheme|(fac 2 1)|, proceeds as
\begin{schemedisplay}
(fac 2 1)
(if (zero? 2) ... (wcm 2 (fac (- 2 1) (* 2 1))))
(wcm 2 (fac (- 2 1) (* 2 1)))
(wcm 2 (fac 1 (* 2 1)))
(wcm 2 (fac 1 2))
(wcm 2 (if (zero? 1) ... (wcm 1 (fac (- 1 1) (* 1 2)))))
(wcm 2 (wcm 1 (fac (- 1 1) (* 1 2))))
\end{schemedisplay}
At this point, there is one \scheme'wcm' directive directly nested within another. Behaviorally, the outer one is collapsed \emph{before} evaluation of the inner body proceeds. In effect, it is overwritten. Following this, evaluation continues as
\begin{schemedisplay}
(wcm 1 (fac (- 1 1) (* 1 2)))
(wcm 1 (fac 0 (* 1 2)))
(wcm 1 (fac 0 2))
(wcm 1 (if (zero? 0) (begin (print (ccm)) 2) ...))
(wcm 1 (begin (print (ccm)) 2))
(wcm 1 (begin (print '(1)) 2))
(wcm 1 (begin 2))
(wcm 1 2)
2
\end{schemedisplay}
The visible effect of the call is
\begin{verbatim}
> (fac 2 1)
(1)
2
\end{verbatim}
from which the overwriting which occurred is evidenced the singleton list obtained by \scheme|(ccm)|.

Using this mechanism, the principal onus of a statistical profiler, algebraic stepper, or debugger can be met by a straightforward language transformation which recursively wraps each term in a \scheme'wcm' directive annotating the continuation with a description of the wrapped term.

With this understanding of continuation marks, we can now formalize them behaviorally.

\section{Language Core and Extension}

In order to formalize continuation marks, we introduce an extension of the \lc with facilities to manipulate continuation marks and present its semantics in the style of Felleisen and Hieb \cite{felleisen1992revised}. Because our ultimate goal is a desugaring transform, we first introduce the target language of the transform, the \lc, in the same way.

\subsection{\lv}

The target language of the transform is Plotkin's call-by-value \lc, \lv\ \cite{plotkin1975call}.

Terms $e$ in \lv\ are the familiar terms of the \lc, defined by
\begin{equation}
e=\app{e}{e}\,|\,v\,|\,x
\end{equation}
where 
\begin{equation}
v=\abs{x}{e}
\end{equation}
describes the values of the \lc.

The evaluation model of \lv\ requires a definition of evaluation contexts. We define evaluation contexts $E$ by
\begin{equation}
E=\app{E}{e}\,|\,\app{v}{E}\,|\,\hole
\end{equation}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The reduction relation of \lv\ is defined simply by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]
\end{align}
where $e[x\leftarrow v]$ denotes a capture-avoiding substitution of every free occurrence of $x$ in $e$ with $v$.

\subsection{\cm}

The source language of the transformation is an extension of \lv\ with facilities for continuation marks which we term \cm.

Because \cm\ is an extension of \lv, the definition of terms $e$ in \cm\ 
\begin{equation}
e=\wcm{e}{e}\,|\,\ccm\,|\,\app{e}{e}\,|\,v\,|\,x
\end{equation}
is identical to that of \lv\ with the addition of two forms for manipulating continuation marks: \scheme'wcm', short for \scheme'with-continuation-mark', which annotates the continuation with the evaluation of the given mark expression; and \scheme'ccm', short for \scheme'current-continuation-marks', which retrieves the current continuation marks.

The sole novelty of \cm\ above the plain \lv\ is the ability to annotate and observe the continuation. Our evaluation model of \cm, given by Pettyjohn et al. \cite{pettyjohn2005continuations}, utilizes the current evaluation context for that purpose. Evaluation contexts $E$ are defined by
\begin{align}
E=\, &\wcm{v}{F}\,|\,F\\
F=\, &\app{E}{e}\,|\,\app{v}{E}\,|\,\wcm{E}{e}\,|\,\hole
\end{align}
The definition of $E$ is crafted to prevent directly nested \scheme'wcm' directives from occurring in valid evaluation contexts.

The reduction relation of \cm\ is defined by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]\label{reduction}\\
E[\wcm{v}{\wcm{v'}{e}}] &\rr E[\wcm{v'}{e}]\label{tail-enforce}\\
E[\wcm{v}{v'}]          &\rr E[v']\label{wcm-body}\\
E[\ccm]                 &\rr E[\chi(E)]\label{ccm-in-context}
\end{align}

As an extension of \lv, \cm\ inherits rule \ref{reduction} with substitution carried through \scheme'wcm' terms.

If directly-nested \scheme'wcm' directives are introduced into the evaluation context, invalidating it (as in the tail-recursive factorial example), rule \ref{tail-enforce} collapses the outer into the inner.

Rule \ref{wcm-body} defines the value of a \scheme'wcm' expression to take on the value of the body, once obtained.

The definition of rule \ref{ccm-in-context} is given in terms of a metafunction $\chi$ defined by
\begin{equation}
\chi(E)=\chi'(E,\abs{x}{\abs{y}{y}})
\end{equation}
where $\chi'$ is defined by
\begin{align}
\chi'(\wcm{v}{F},vs) &= \chi'(F,\abs{z}{\app{\app{z}{v}}{vs}})\\
\chi'(\app{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\app{v}{E},vs) &= \chi'(E,vs)\\
\chi'(\wcm{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\hole,vs)      &= vs
\end{align}
This definition formalizes the intuition given earlier regarding the behavior of \scheme'ccm'. Previously, we saw that the value of a \scheme'ccm' directive was a list; however, lists do not strictly exist as values in the \lc, nor in our extension. Instead of adding lists as primitive values to \cm, we employ Church-encodings to represent them natively \cite{barendregt1984lambda}.

%The accumulator-passing style definition of $\chi$ has the effect of ordering the marks from most- to least-recently placed.

Let $\lvrr$ denote the reduction relation for \lv\ and $\lvrrs$ its transitive closure. Similarly, let $\cmrr$ denote the reduction relation for \cm\ and $\cmrrs$ its transitive closure. We will use the more specific notation when $\rightarrow$ is potentially ambiguous.

With the source and target languages formally specified, we can now examine a language transformation in earnest.

\setkeyword{cons snd}
\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{e_0}{$e_0$}
\setspecialsymbol{e_0p}{$e'_0$}
\setspecialsymbol{Ce_0}{$\C{e_0}$}
\setspecialsymbol{Ce_0p}{$\C{e'_0}$}
\setspecialsymbol{x_1}{$x_1$}
\setspecialsymbol{x_n}{$x_n$}
\setspecialsymbol{e_1}{$e_1$}
\setspecialsymbol{e_n}{$e_n$}
\setspecialsymbol{Ce_1}{$\C{e_1}$}
\setspecialsymbol{Ce_1p}{$\C{e'_1}$}
\setspecialsymbol{Cv}{$\C{v}$}
\setspecialsymbol{v_0}{$v_0$}
\setspecialsymbol{Cv_0}{$\C{v_0}$}
\setspecialsymbol{Cv_0p}{$\C{v'_0}$}
\setspecialsymbol{Cpv_0}{$\Cp{v_0}$}
\setspecialsymbol{Cpv_1}{$\Cp{v_1}$}
\setspecialsymbol{v_1}{$v_1$}
\setspecialsymbol{T}{$\mathcal{A}$}
\setspecialsymbol{C}{$\mathcal{C}$}
\setspecialsymbol{Cp}{$\mathcal{C}'$}
\setspecialsymbol{hole}{$\hole$}
\setspecialsymbol{bottom}{$\perp$}
\setspecialsymbol{Ce_0p_x_Cpv_1}{$\C{e'_0}[x\leftarrow\Cp{v_1}]$}
\setspecialsymbol{e_0p_x_v_1}{$e'_0[x\leftarrow v_1]$}
\setspecialsymbol{Cz}{$\C{z}$}
\setspecialsymbol{CE}{$\C{E}$}
\setspecialsymbol{xiE}{$\xi(E)$}
\setspecialsymbol{chiE}{$\chi(E)$}
\setspecialsymbol{CchiE}{$\C{\chi(E)}$}

\setspecialsymbol{TRUE}{$\mathbf{true}$}
\setspecialsymbol{FALSE}{$\mathbf{false}$}
\setspecialsymbol{PAIR}{$\mathbf{pair}$}
\setspecialsymbol{CONS}{$\mathbf{cons}$}
\setspecialsymbol{FST}{$\mathbf{fst}$}
\setspecialsymbol{SND}{$\mathbf{snd}$}
\setspecialsymbol{NIL}{$\mathbf{nil}$}

\newcommand{\true}{\mathbf{true}}
\newcommand{\false}{\mathbf{false}}
\newcommand{\nil}{\mathbf{nil}}
\newcommand{\pair}[2]{((\mathbf{pair}\,#1)\,#2)}
\newcommand{\eval}[1]{\overline{#1}}

\section{Transformation}

As transformations, desugarings put the meaning of one construct in terms of another. If the meaning of the former was given only informally, the desugaring offers a new definition as formal as the definition of the latter. In this way, desugarings offer a convenient way to provide meaning to a construct and avoid enlarging the language. If, however, the sugared language already has a formal meaning, as does \cm, the desugaring must preserve it.

We will define a transformation from \cm\ to \lv\ and term it $\mathcal{C}$, as in \emph{compile}, since we are, in essence, compiling away continuation marks. In order to preserve the meaning of \cm, $\mathcal{C}$ must commute with evaluation. More precisely, for programs $p\in\lambda_{cm}$,
\[
\begin{array}{ccc}
p & \cmrrs & v\\
\downarrow_\mathcal{C} & & \downarrow_\mathcal{C}\\
\C{p} & \lvrrs & \C{v}
\end{array}
\]
should hold, or, more succinctly,
\begin{equation}
\label{meaning-preservation-property}
p\cmrrs v\implies\C{p}\lvrrs\C{v}
\end{equation}

\subsection{Intuition}

The essence of \cm\ is that programs can apply information to and observe information about the context in which they are evaluated. Programs in \lv\ have no such facility. We can simulate this facility by explicitly passing contextual information to each term as it is evaluated. We can define $\mathcal{C}$ to transform \scheme'wcm' directives to manipulate this information and \scheme'ccm' directives to access it. Intuitively, we can transform \cm\ programs to mark-passing style.

However, marks alone do not account for the tail-call behavior specified by rule \ref{tail-enforce}. Since tail-call behavior is observable (if indirectly) by \cm\ programs, we must also provide to each term information about the position in which it is evaluated. Specifically, each transformed \scheme'wcm' directive must be notified whether it is evaluated in tail position of an enclosing \scheme'wcm' directive as it must behave specially if so. Thus, in addition to passing the current continuation marks, the transform should pass a flag to each term indicating whether it is evaluated in tail position of a \scheme'wcm' directive.

%Since this is a dynamic property of the evaluation, we do not attempt to infer it statically.

These two pieces of information suffice to correctly simulate continuation marks.

%These two functions of the context are sufficient to simulate continuation marks, and they characterize the purpose/approach of the transform: to propagate contextual information to each expression, manipulating it appropriately as the context changes. With this in mind, we now formally define $\mathcal{C}$.

%The transformation $\mathcal{C}$ is inductively defined over each syntactic form of \cm.



%The treatment of \scheme'wcm' will require care as it is especially sensitive to evaluation order. Assuming termination for all constituent evaluations, consider
%\begin{align*}
%       &E[\wcm{e_0}{\wcm{e_1}{e_2}}]\\
%\cmrrs &E[\wcm{v_0}{\wcm{e_1}{e_2}}]\\
%\cmrrs &E[\wcm{v_0}{\wcm{v_1}{e_2}}]\\
%\cmrr  &E[\wcm{v_1}{e_2}]\\
%\cmrrs &E[\wcm{v_1}{v_2}]\\
%\cmrr  &E[v_2]
%\end{align*}
%We will need to arrange arguments in such a way that the natural call-by-value evaluation order of \lv\ accomplishes correct evaluation order according to the semantics of \cm.

%The treatment of \scheme'ccm' simply needs access to the evaluation of $\chi$ on the current context. As \lv\ lacks any facility to observe the context, the transformation explicitly provides this information to each \scheme'ccm' expression. The $\chi$ metafunction is continuous in the sense that a small change in the prefix of the input effects only a small change in the prefix of the output, a consequence of its particular recursive definition. This fact means that it is possible to compute $\chi$ incrementally. The transform then ensures that each expression had access to information about its own context.

%Finally, we address the preservation of proper tail-call behavior. Even though tail calls exist in \lv--indeed, they are prevalent--their behavior does not honor proper tail-call behavior through the transform. Thus, we maintain information about the immediate context of the program: specifically, whether evaluation is occurring directly within the body of a \scheme'wcm' expression.

%All together, the transformation adds three arguments to every term $e$: the continuation $k$ representative of the current context $E$; a flag $f$ encoding whether evaluation is occurring with the body of a \scheme'wcm' expression; and the transformed value $m$ of $\chi$ for the current context $\C{\chi(E)}$.

%The formal definition of $\mathcal{C}$ follows.

With this in mind, consider a conceptual transformation \scheme|C[(rator-expr rand-expr)]| as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    (let ((rator-value ((C[rator-expr] FALSE) marks))
          (rand-value ((C[rand-expr] FALSE) marks))
      (((rator-value rand-value) flag) marks))))
\end{schemedisplay}
ignoring for the moment that \scheme'let' is in neither \lv\ or \cm. This definition captures that
\begin{enumerate}
\item before evaluation, we expect \scheme'flag' to indicate tail position information and \scheme'marks' to provide a list of the current continuation marks,
\item we would like to evaluate \scheme'C[rator-expr]' and \scheme'C[rand-expr]' in the same manner, providing to each its contextual information--specifically that neither is evaluated in tail position of a \scheme'wcm' directive and the continuation marks for each are unchanged from the parent context,
\item and, following evaluation of operator and operand and application, evaluation of the resultant term is performed with the original contextual information.
\end{enumerate}

Now consider a conceptual transformation \scheme|C[(wcm mark-expr body-expr)]| as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    ((C[body-expr] TRUE) (let ((mark-value ((C[mark-expr] FALSE) marks))
                               (rest-marks (if flag (snd marks) marks)))
                           (cons mark-value rest-marks)))))
\end{schemedisplay}
with similar caveats as the previous case. This definition captures that
\begin{enumerate}
\item as in application, we expect \scheme'flag' to indicate tail position information and \scheme'marks' to provide a list of the current continuation marks,
\item we evaluate \scheme'mark-expr' with correct contextual information,
\item we discard the first continuation mark of the parent context if evaluation is occurring in tail position of a \scheme'wcm' directive,
\item and we evaluate \scheme'C[body-expr]' with the correct tail-position flag and current continuation marks.
\end{enumerate}

Finally, consider the conceptual transformation \scheme|C[(ccm)]| as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    marks))
\end{schemedisplay}
wherein we reap the fruits of simplicity from our laborious passing: this definition is gratifyingly direct.

The conceptual transformation of variables \scheme'x' and values \scheme'(lambda (x) e)' is straightforward.

We now address the absence of \scheme'let', \scheme'if', \scheme'cons', etc. from \lv.

We can express the \scheme'let' construct in \lv\ with application. An expression such as
\begin{schemedisplay}
(let ((x_1 e_1)
      ...
      (x_n e_n))
  e)
\end{schemedisplay}
can be interpreted as
\begin{schemedisplay}
(...((lambda (x_1) ... (lambda (x_n)
           e)...) e_1) ...) e_n)
\end{schemedisplay}
which is the curried form of
\begin{schemedisplay}
((lambda (x_1 ... x_n)
           e) e_1 ... e_n)
\end{schemedisplay}

We use the Church encodings of \scheme'if' and conditionals as well as for list-manipulation operators \scheme{cons}, etc. \cite{barendregt1984lambda}.
 
\subsection{One final concern}

Our choice to keep the core language small by omitting lists as primitive values has the consequence of complicating our transform somewhat. Because lists are defined in terms of \lc\ values which are themselves touched by the transform and because of the commutativity property that $\mathcal{C}$ must satisfy, we cannot deal with a list of continuation marks directly--we must instead deal with a transformed list of transformed continuation marks.

\newenvironment{schemedefn}[1]{\begin{definition}$#1$}{\end{definition}}
\newenvironment{namedschemedefn}[2]{\begin{definition}\label{#1}$#2$}{\end{definition}}



\subsection{Useful Shorthand}

We first define a useful shorthand.

\begin{figure}
\begin{align*}
\true         &= \abs{x}{\abs{y}{x}}\\
\false        &= \abs{x}{\abs{y}{y}}\\
\mathbf{pair} &= \abs{a}{\abs{b}{\abs{z}{\app{\app{z}{a}}{b}}}}\\
\mathbf{fst}  &= \abs{p}{\app{p}{\true}}\\
\mathbf{snd}  &= \abs{p}{\app{p}{\false}}\\
\nil          &= \false
\end{align*}
\label{chuch-encodings}
\caption{Church encodings of booleans and lists}
\end{figure}

\subsection{Definition of $\mathcal{C}$}

The definition of $\mathcal{C}$ over the five syntactic forms of \cm\ follows.

\begin{schemedefn}{\C{\app{e_0}{e_1}}}
\begin{schemedisplay}
(lambda (k)
   (lambda (f)
     (lambda (m)
       (((Ce_0
          (lambda (v_0)
            (((Ce_1
               (lambda (v_1)
                 ((((v_0 v_1) k) f) m)))
              FALSE)
             m)))
         FALSE)
        m))))
\end{schemedisplay}
\end{schemedefn}

The evaluation of operator and operand in an application enlarges the continuation, so marks made within said evaluation will not interfere with pre-existent marks, and this is reflected by the $\false$ flag passed to each. Once the arguments are evaluated, the new context is unnecessary and discarded. The application itself inherits the flag of the original context.

\begin{schemedefn}{\C{\wcm{e_0}{e_1}}}
\begin{schemedisplay}
(lambda (k)
  (lambda (f)
    (lambda (m)
      (((Ce_0
         (lambda (v_0) ((lambda (k) 
                        (k (((m (lambda (x) x)) (lambda (z) z)) (lambda (z) z))))
                      (lambda (t) 
                        ((lambda (k) (k ((f C[(SND t)]) t)))
                         (lambda (r) 
                           (((Ce_1 k) TRUE) C[(PAIR v_0 r)])))))))
        FALSE)
       m))))
\end{schemedisplay}
\end{schemedefn}

The definition over \scheme'wcm' expressions is the only one to make explicit use of the value of the flag. Following the evaluation of the mark expression, rule \ref{tail-enforce} is applied, if necessary. The continuity of $\chi$ allows us to construct $\chi(E''[\wcm{v_0}{e_1}])$ from $\chi(E)$ where 

\begin{equation}
E''=\begin{cases}
E' &\text{if $E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}\\
E &\text{otherwise}
\end{cases}
\end{equation}

\begin{schemedefn}{\C{\ccm}}
\begin{schemedisplay}
(lambda (k)
  (lambda (f)
    (lambda (m)
      (((m k) (lambda (z) z)) (lambda (z) z)))))
\end{schemedisplay}
\end{schemedefn}

The simplicity of the definition over \scheme`ccm` expressions offsets the work performed by the other definitions: it simply returns the list passed in.

\begin{definition}
$\C{v_0}=\C{\abs{x}{e'_0}}=\abs{k}{\abs{f}{\abs{m}{\app{k}{\abs{x}{\C{e'_0}}}}}}$
\end{definition}

\begin{definition}
$\C{x}=\abs{k}{\abs{f}{\abs{m}{\app{k}{x}}}}$
\end{definition}

%\subsection{Example: Factorial}

%For convenience, we will augment the base language with direct forms for expressing factorial. Define terms $e$ in \lv\ by
%\begin{equation}
%e=\app{e}{e}\,|\,(*\,e\,e)\,|\,\app{\mathrm{pred}}{e}\,|\,\app{\mathrm{zero?}}{e}\,|\,v\,|\,x
%\end{equation}
%and values $v$ by
%\begin{equation}
%v=\abs{x}{e}\,|\,\mathbb{N}
%\end{equation}
%.

%We can express the factorial function by the following
%\begin{schemedisplay}
%(Y (lambda (f)
%     (lambda (n)
%       (((zero? n)
%         1)
%        (* n (f (pred n)))))))
%\end{schemedisplay}

%and with continuation marks by
%\begin{schemedisplay}
%(Y (lambda (f)
%     (lambda (n)
%       (((zero? n)
%         (print (ccm) 1))
%        (* n (wcm n (f (pred n))))))))
%\end{schemedisplay}

\section{Testing}

A pragmatic approach to the discovery of a correct transformation involves consistent feedback and testing to validate candidate transforms. Testing is no substitute for proof, but, as Klein et al. \cite{klein2012run} show, proof is no substitute for testing. Lightweight mechanization is a fruitful middle ground between pencil-and-paper analysis and fully-mechanized formal proof. We use Redex \cite{findler2010redex}, a domain-specific language for exploring language semantics, to provide feedback, thoroughly exercise candidates, and perform exploratory analysis.

The correctness of the transform lies in the property that it commutes. In order to test for this property, we must construct evaluation models for the source language \cm\ and the target language \lv. Since \cm\ is an extension of \lv, many of its forms and semantics are inherited. Redex allows us to exploit this fact by defining a model for \lv\ first and then extending that model with the enhancements of \cm.

\setkeyword{define-language define-extended-language define-metafunction reduction-relation extend-reduction-relation define-metafunction/extension in-hole hole variable-not-otherwise-mentioned}
\setkeyword{wcm ccm}

\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{->}{$\to$}
\setspecialsymbol{-->}{$\rightarrow$}
\setspecialsymbol{betav}{$\beta$v}
\setconstant{error}
\setkeyword{chi chi_p number apply-reduction-relation*}

\setspecialsymbol{lambdav}{$\lambda$v}
\setspecialsymbol{lambdav-rr}{$\lambda$v-rr}
\setspecialsymbol{lambdav-subst}{$\lambda$v-subst}

We first define the form of terms $e$, values $v$, and evaluation contexts $E$.

\begin{schemedisplay}
(define-language lambdav
  (e (e e) x v error)
  (x variable-not-otherwise-mentioned)
  (v (lambda (x) e) number)
  (E (E e) (v E) hole))
\end{schemedisplay}

We then define the reduction relation for \lv. It consists of five rules. The first rule captures the sole semantic rule of \lv; the remaining handle error conditions.

\begin{schemedisplay}
(define lambdav-rr
  (reduction-relation lambdav
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdav-subst x v e))
        "betav")
   (--> (in-hole E (number_1 v))
        (in-hole E error)
        "error: number in operator position")
   (--> (in-hole E x)
        (in-hole E error)
        "error: unbound identifier")
   (--> (in-hole E (error e))
        (in-hole E error)
        "error in operator")
   (--> (in-hole E (v error))
        (in-hole E error)
        "error in operand")))
\end{schemedisplay}

The reduction relation requires one metafunction to perform substitution. We omit any capture-avoidance facilities to keep the model simple and argue that it is unnecessary as we generate fresh variables in the transform.

\begin{schemedisplay}
(define-metafunction lambdav
  lambdav-subst : x v e -> e
  ;; 1. substitute in application
  [(lambdav-subst x_1 v_1 (e_1 e_2))
   ((lambdav-subst x_1 v_1 e_1) (lambdav-subst x_1 v_1 e_2))]
  ;; 2a. substitute in variable (same)
  [(lambdav-subst x_1 v_1 x_1)
   v_1]
  ;; 2b. substitute in variable (different)
  [(lambdav-subst x_1 v_1 x_2)
   x_2]
  ;; 3a. substitute in abstraction (bound)
  [(lambdav-subst x_1 v_1 (lambda (x_1) e_1))
   (lambda (x_1) e_1)]
  ;; 3b. substitute in abstraction (free)
  [(lambdav-subst x_1 v_1 (lambda (x_2) e_1))
   (lambda (x_2) (lambdav-subst x_1 v_1 e_1))]
  ;; 4. substitute in number
  [(lambdav-subst x_1 v_1 number_1)
   number_1]
  ;; 5. substitute in error
  [(lambdav-subst x_1 v_1 error)
   error])
\end{schemedisplay}




\setspecialsymbol{lambdacm}{$\lambda$cm}
\setspecialsymbol{lambdacm-rr}{$\lambda$cm-rr}
\setspecialsymbol{lambdacm-subst}{$\lambda$cm-subst}

We now define the forms of terms $e$, and evaluation contexts $E$ and $F$, inheriting definitions from \lv\ where appropriate.

\begin{schemedisplay}
(define-extended-language lambdacm lambdav
  (e .... (wcm e e) (ccm))
  (E (wcm v F) F)
  (F (E e) (v E) (wcm E e) hole))
\end{schemedisplay}

We extend the reduction relation of \lv. We begin by redefining application in terms of a substitution function aware of \cm. The following three definitions capture the remaining semantic rules of \cm. The remaining definitions handle error cases specific to \cm.

\begin{schemedisplay}
(define lambdacm-rr
  (extend-reduction-relation lambdav-rr lambdacm
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdacm-subst x v e))
        "betav")
   (--> (in-hole E (wcm v_1 (wcm v_2 e)))
        (in-hole E (wcm v_2 e))
        "wcm-collapse")
   (--> (in-hole E (wcm v_1 v_2))
        (in-hole E v_2)
        "wcm")
   (--> (in-hole E (ccm))
        (in-hole E (chi E))
        "chi")
   (--> (in-hole E (wcm error e))
        (in-hole E error)
        "error in wcm mark expression")
   (--> (in-hole E (wcm v error))
        (in-hole E error)
        "error in wcm body expression")))
\end{schemedisplay}

We extend the definition of substitution to accommodate the additional forms introduced by \cm.

\begin{schemedisplay}
(define-metafunction/extension lambdav-subst lambdacm
  lambdacm-subst : x v e -> e
  ;; 1. substitute in wcm form
  [(lambdacm-subst x_1 v_1 (wcm e_1 e_2))
   (wcm (lambdacm-subst x_1 v_1 e_1) (lambdacm-subst x_1 v_1 e_2))]
  ;; 2. substitute in ccm form
  [(lambdacm-subst x_1 v_1 (ccm))
   (ccm)])
\end{schemedisplay}

The definition of \scheme'chi' and \scheme'chi_p' mirror their definitions exactly.

\begin{schemedisplay}
(define-metafunction lambdacm
  chi : E -> v
  [(chi E) (chi_p E (lambda (x) (lambda (y) y)))])

(define-metafunction lambdacm
  chi_p : E v -> v
  [(chi_p hole v_ms)      v_ms]
  [(chi_p (E e) v_ms)     (chi_p E v_ms)]
  [(chi_p (v E) v_ms)     (chi_p E v_ms)]
  [(chi_p (wcm E e) v_ms) (chi_p E v_ms)]
  [(chi_p (wcm v E) v_ms) (chi_p E (lambda (p) ((p v) v_ms)))])
\end{schemedisplay}

We are now prepared to test various semantic properties of these two languages. Of course, we are interested in testing the commutativity of our transform. We observe that a mark-passing approach, much like a continuation-passing approach, abstracts terms and so requires a transformed term to be primed with an argument to initiate reduction. For this reason, we accompany each transform with an initialization function which primes a term appropriately for the corresponding transform.

\setkeyword{meaning-preserved? alpha-eq? transform eval init redex-check}

We can test that the property described by equation \ref{meaning-preservation-property} holds for a given program \scheme'p' with 
\begin{schemedisplay}
(define (meaning-preserved? p)
  (alpha-eq? (transform (eval lambdacm p)) (eval lambdav (init (transform p)))))
\end{schemedisplay}
where \scheme'alpha-eq?' determines $\alpha$-equivalence between two \lc\ terms and \scheme'eval' is an alias for the Redex native \scheme'apply-reduction-relation*'.

Redex provides convenient functions to initiate random testing.

\begin{schemedisplay}
(redex-check lambdacm e (meaning-preserved? e))
\end{schemedisplay}

\scheme'redex-check' generates random terms according to the grammar of the given language (\scheme'lambdacm') and category (\scheme'e') in search of counterexamples to the predicate. 

\section{Proof}

\begin{definition}
\[
\mathrm{eval}_{cm}(p)=\begin{cases}
v     &\text{if $p\cmrrs v$}\\
\perp &\text{if $p\cmrrs\cdots$}
\end{cases}
\]
\end{definition}

\begin{definition}
\[
\mathrm{eval}_{v}(p)=\begin{cases}
v     &\text{if $p\lvrrs v$}\\
\perp &\text{if $p\lvrrs\cdots$}
\end{cases}
\]
\end{definition}

\newtheorem{maintheorem}{Correctness of $\mathcal{C}$}
\begin{maintheorem}
For all programs $p\in\lambda_{cm}$, $\C{\mathrm{eval}_{cm}(p)}=\mathrm{eval}_{v}(\C{p})$.
\end{maintheorem}

\section{Back to JavaScript}

With a correct transformation of continuation marks defined over the \lc, it requires little to add continuation marks to an eager, higher-order language such as JavaScript.

We add two keywords to manipulate continuation marks: the familiar \texttt{wcm} and \texttt{ccm}. We chose block syntax for \texttt{wcm} to convey that it is a special form, like a conditional, instead of a function-like interface. A lone \texttt{ccm} evaluates to the current continuation marks.

Factorial in this JavaScript extension can be implemented like the following:
\begin{verbatim}
var fac = function( n ) {
    if( n == 0 ) {
        console.log( ccm );
        return 1;
    }
    else {
        return wcm { n }
                   { n * fac( n - 1 ) };
    }
}
\end{verbatim}

A transformation of this function desugars these constructs into valid JavaScript.
\begin{verbatim}
var fac = function( f, m ) {
    return function( n ) {
        if( n == 0 ) {
            console.log( (function( f, m ) { return m; })( false, m ) );
            return 1;
        }
        else {
            return (function( f, m ) {
                return (function( v ) {
                    return n * fac( false, [ v ].concat( f ? m.slice( 1 ) : m ) )( n - 1 );
                })( n );
            })( f, m );
        }
    }
}
\end{verbatim} 

\section{Conclusion}

Continuation marks support a bevy of instrumentation tools and advanced language features in a generalized, portable way. Despite their demonstrated utility, they have not yet found their way into most languages. A verified characterization of continuation marks in a pure computational language provides implementors of higher-order languages a correct compiler for continuation marks.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}
