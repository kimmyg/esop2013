\documentclass{llncs}

\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{slatex}
\usepackage{color}

\title{Instant Continuation Marks--Just Add $\lambda$}

\author{Kimball Germane \and Jay McCarthy}
\institute{Brigham Young University}

% Look at the many other papers on c marks to justify them (see mine for
% example). Talk about how your transformation is a compiler and right
% now no language but Racket has C-marks, so we could use this to get
% them in that language. For Racket though, now they don't need to be
% built in to the compiler if we don't want. In addition, it makes it
% easier to do a type system.

\spnewtheorem{plaindef}{Definition}{\bfseries}{\rmfamily}

\setkeyword{wcm ccm with-continuation-mark current-continuation-marks}
\setkeyword{print fac zero?}

\newcommand{\cm}[0]{$\lambda_{cm}$}
\newcommand{\lv}[0]{$\lambda_v$}
\newcommand{\lc}[0]{$\lambda$-calculus}
\newcommand{\wcm}[2]{(\mathrm{wcm}\,#1\,#2)}
\newcommand{\ccm}[0]{(\mathrm{ccm})}
\newcommand{\wcmb}[2]{(\mathbf{wcm}\,#1\,#2)}
\newcommand{\ccmb}[0]{(\mathbf{ccm})}
\newcommand{\app}[2]{(#1\,#2)}
\newcommand{\abs}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\hole}[0]{\bullet}
\newcommand{\rr}[0]{\rightarrow}
\newcommand{\lrrs}[0]{\rightarrow^{*}}
\newcommand{\lvrr}[0]{\rightarrow_v}
\newcommand{\lvrrs}[0]{\rightarrow_v^{*}}
\newcommand{\cmrr}[0]{\rightarrow_{cm}}
\newcommand{\cmrrs}[0]{\rightarrow_{cm}^{*}}
\newcommand{\C}[1]{\mathcal{C}[#1]}
\newcommand{\Cp}[1]{\mathcal{C}'[#1]}
\newcommand{\Ch}[1]{\hat{\mathcal{C}}[#1]}
\newcommand{\Ccps}[1]{\mathcal{C}_{\mathrm{cps}}[#1]}
\newcommand{\Cpcps}[1]{\mathcal{C}'_{\mathrm{cps}}[#1]}
\newcommand{\Chcps}[1]{\hat{\mathcal{C}}_{\mathrm{cps}}[#1]}
\newcommand{\evalv}[1]{\mathrm{eval}_v(#1)}
\newcommand{\evalcm}[1]{\mathrm{eval}_{cm}(#1)}

\begin{document}

\maketitle

\begin{abstract}
Continuation marks are a programming language feature which generalizes stack inspection. Despite its usefulness, this feature has not been adopted by languages which rely on stack inspection, e.g., for dynamic security checks. One reason for this neglect may be that continuation marks do not yet enjoy a transformation to the plain $\lambda$-calculus which would allow higher-order languages to provide continuation marks at little cost.

We present direct and CPS-like transformations from the call-by-value $\lambda$-calculus augmented with continuation marks to the pure call-by-value $\lambda$-calculus. We discuss how such transformations simplify the construction of compilers which treat continuation marks correctly. We document the aide of Redex, a domain-specific language for exploring language semantics, in the discovery of correct transformations. Finally, we verify the transformations with the proof of a meaning-preservation theorem.
\end{abstract}

\section{Introduction}

Numerous programming language instruments rely on stack inspection to function. Statistical profilers sample the stack regularly to record active functions, algebraic steppers observe the stack to represent the evaluation context of an expression, and debuggers naturally require consistent access to the stack. In each of these scenarios, the instrument relies on implementation-specific information and must be maintained as the instrumented language undergoes optimizations and ventures across platforms. This makes these instruments brittle and increases the porting cost of the language ecosystem. Each would benefit from a generalized stack-inspection mechanism available within the instrumented language itself. If written in such an enhanced language, each instrument would be more robust, more easily modified, and would port for free.

Continuation marks \cite{clements2006portable} are a programming language feature which generalizes stack inpection. Not only do they dramatically simplify correct instrumentation \cite{clements2001modeling}, they have been used to allow inspection-based dynamic security checks in the presence of tail-call optimization \cite{clements2004tail} and to express aspect-oriented programming in higher-order languagues \cite{tucker2003pointcuts}.

Continuation marks originated in PLT Scheme (now Racket \cite{plt-tr1}). However, in spite of their usefulness, continuation marks have remained absent from programming languages at large. One reason for this is that retrofitting virtual machines to accommodate the level of stack inspection continuation marks must provide is expensive, especially when the virtual machines use the host stack for efficiency.

For example, the ubiquitous JavaScript is an ideal candidate for the addition of continuation marks. However, as the lingua franca of the web, it has numerous mature implementations which have been heavily optimized. To add continuation marks to JavaScript amounts to modifying each implementation upstream, to say nothing of amending the JavaScript standard. (Clements et al. successfully added continuation marks in Mozilla's Rhino compiler \cite{clements2008implementing}, but it remains a proof-of-concept.)

To avoid this roadblock, we instead take a macro-style approach; that is, we enhance the core language with facilities to manipulate continuation marks and desugar the enhanced language back to the core. To make our desugaring transformation portable to other languages, we define it over the \lc, the common core of most higher-order languages. With such a transformation, language semanticists do not need to reconcile the feature with other features in the language (provided they have already done so with $\lambda$) and their compiler writers do not need to worry about complicating their implementations (for the same reason).

We begin by further explaining continuation marks in section \ref{sec-continuation-marks}. We then formalize them via the introduction of a core and enhanced language in section \ref{sec-core-and-extension}. We discuss the necessary properties of a meaningful transformation between these languages. We present two transformations of continuation marks--one direct and one CPS-like--to the call-by-value \lc in section \ref{sec-transformation}. This is followed by a lightweight mechanized model for random testing in section \ref{sec-testing} and a proof of a meaning-preservation theorem in section \ref{sec-proof}. We finally apply it to JavaScript in section \ref{sec-javascript}.

\section{Continuation Marks}
\label{sec-continuation-marks}

Continuation marks allow the program to annotate and observe the stack (or continuation). This is accomplished via two surface-level syntactic forms in the language: \scheme'with-continuation-mark', abbreviated \scheme'wcm'; and \scheme'current-continuation-marks', abbreviated \scheme'ccm'.

A \scheme'wcm' expression of the form \scheme|(wcm mark-expr body-expr)| annotates the youngest portion of the continuation with \scheme'mark-value', the evaluation of \scheme'mark-expr', before evaluating \scheme'body-expr' to \scheme'body-value'. If an annotation, or \emph{mark}, already exists on the youngest portion, it is replaced by the new mark. This newly-added mark is available within \scheme'body-expr' via \scheme'ccm' during its evaluation. Once complete, the entire \scheme'wcm' expression takes on \scheme'body-value'.

A \scheme'ccm' expression of the form \scheme|(ccm)| traverses the continuation accumulating a list of annotations ascending in age.

\subsection{Example}

The traditional, properly-recursive factorial function can be expressed with continuation marks as follows:
\begin{schemedisplay}
(define (fac n)
  (if (zero? n)
      (begin
        (print (ccm))
        1)
      (wcm n (* n (fac (- n 1))))))
\end{schemedisplay}
In this definition, a multiplication pends following the recursive call, so the continuation grows with each.

The evaluation of the factorial of 2, expressed by \scheme|(fac 2)|, proceeds as
\begin{schemedisplay}
(fac 2)
(if (zero? 2) ... (wcm 2 (* 2 (fac (- 2 1)))))
(wcm 2 (* 2 (fac (- 2 1))))
(wcm 2 (* 2 (fac 1)))
(wcm 2 (* 2 (if (zero? 1) ... (wcm 1 (* 1 (fac (- 1 1)))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac (- 1 1))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac 0)))))
(wcm 2 (* 2 (wcm 1 (* 1 (if (zero? 0) (begin (print (ccm)) 1) ...)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print (ccm)) 1)))))
\end{schemedisplay}
At this point, the term \scheme|(ccm)| is evaluated. This happens, in effect, by walking the continuation and building a list of the current continuation marks which appear in the \scheme'mark-value' position of a \scheme'wcm' term. In this example, \scheme|(ccm)| evaluates to \scheme|'(1 2)|. Evaluation continues as
\begin{schemedisplay}
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print '(1 2)) 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 1))))
(wcm 2 (* 2 (wcm 1 1)))
(wcm 2 (* 2 1))
(wcm 2 2)
2
\end{schemedisplay}
The visible effect of the call is
\begin{verbatim}
> (fac 2)
(1 2)
2
\end{verbatim}

In a tail-call optimized language, a call made in tail position does not enlarge the continuation. Instead, the portion of the evaluation context dedicated to the calling function is repurposed for the called function. Continuation marks are also subject to this optimization; if the continuation is marked in tail position, the previous mark there is replaced, if it exists.

This behavior is apparent in the tail-recursive definition of the factorial function, which follows.
\begin{schemedisplay}
(define (fac n acc)
  (if (zero? n)
      (begin
        (print (ccm))
        acc)
      (wcm n (fac (- n 1) (* n acc)))))
\end{schemedisplay}
In this definition, the multiplication is performed before the recursive call and an accumulated value is passed. With no pending computation, the evaluation context devoted to this function is no longer necessary, and is subsumed by the continuation mark directive.

The evaluation of the factorial of 2, here expressed by \scheme|(fac 2 1)|, proceeds as
\begin{schemedisplay}
(fac 2 1)
(if (zero? 2) ... (wcm 2 (fac (- 2 1) (* 2 1))))
(wcm 2 (fac (- 2 1) (* 2 1)))
(wcm 2 (fac 1 (* 2 1)))
(wcm 2 (fac 1 2))
(wcm 2 (if (zero? 1) ... (wcm 1 (fac (- 1 1) (* 1 2)))))
(wcm 2 (wcm 1 (fac (- 1 1) (* 1 2))))
\end{schemedisplay}
At this point, there is one \scheme'wcm' directive directly nested within another. Behaviorally, the outer one is collapsed \emph{before} evaluation of the inner body proceeds. In effect, it is overwritten. Following this, evaluation continues as
\begin{schemedisplay}
(wcm 1 (fac (- 1 1) (* 1 2)))
(wcm 1 (fac 0 (* 1 2)))
(wcm 1 (fac 0 2))
(wcm 1 (if (zero? 0) (begin (print (ccm)) 2) ...))
(wcm 1 (begin (print (ccm)) 2))
(wcm 1 (begin (print '(1)) 2))
(wcm 1 (begin 2))
(wcm 1 2)
2
\end{schemedisplay}
The visible effect of the call is
\begin{verbatim}
> (fac 2 1)
(1)
2
\end{verbatim}
from which the overwriting which occurred is evidenced the singleton list obtained by \scheme|(ccm)|.

Using this mechanism, the principal onus of a statistical profiler, algebraic stepper, or debugger can be met by a straightforward language transformation which recursively wraps each term in a \scheme'wcm' directive annotating the continuation with a description of the wrapped term.

With this understanding of continuation marks, we can now formalize them behaviorally.

\section{Language Core and Extension}
\label{sec-core-and-extension}

In order to formalize continuation marks, we introduce an extension of the \lc\ with facilities to manipulate continuation marks and present its semantics in the style of Felleisen and Hieb \cite{felleisen1992revised}. Because our ultimate goal is a desugaring transform, we first introduce the target language of the transform, the \lc, in the same way.

\subsection{\lv}

The target language of the transform is Plotkin's call-by-value \lc, \lv\ \cite{plotkin1975call}, augmented with natural numbers.

Terms $e$ in \lv\ are the familiar terms of the \lc, defined by
\begin{equation}
e=\app{e}{e}\,|\,v\,|\,x
\end{equation}
where 
\begin{equation}
v=\abs{x}{e}\,|\,n
\end{equation}
with $n\in\mathbb{N}$.

The evaluation model of \lv\ requires a definition of evaluation contexts. We define evaluation contexts $E$ by
\begin{equation}
E=\app{E}{e}\,|\,\app{v}{E}\,|\,\hole
\end{equation}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The reduction relation of \lv\ is defined simply by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]
\end{align}
where $e[x\leftarrow v]$ denotes a capture-avoiding substitution of every free occurrence of $x$ in $e$ with $v$.

\subsection{\cm}

The source language of the transformation is an extension of \lv\ with facilities for continuation marks which we term \cm.

Because \cm\ is an extension of \lv, the definition of terms $e$ in \cm\ 
\begin{equation}
e=\wcm{e}{e}\,|\,\ccm\,|\,\app{e}{e}\,|\,v\,|\,x
\end{equation}
is identical to that of \lv\ with the addition of two forms for manipulating continuation marks: \scheme'wcm', short for \scheme'with-continuation-mark', which annotates the continuation with the evaluation of the given mark expression; and \scheme'ccm', short for \scheme'current-continuation-marks', which retrieves the current continuation marks.

The sole novelty of \cm\ above the plain \lv\ is the ability to annotate and observe the continuation. Our evaluation model of \cm, given by Pettyjohn et al. \cite{pettyjohn2005continuations}, utilizes the current evaluation context for that purpose. Evaluation contexts $E$ are defined by
\begin{align}
E=\, &\wcm{v}{F}\,|\,F\\
F=\, &\app{E}{e}\,|\,\app{v}{E}\,|\,\wcm{E}{e}\,|\,\hole
\end{align}
The definition of $E$ is crafted to prevent directly nested \scheme'wcm' directives from occurring in valid evaluation contexts.

The reduction relation of \cm\ is defined by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]\label{reduction}\\
E[\wcm{v}{\wcm{v'}{e}}] &\rr E[\wcm{v'}{e}]\label{tail-enforce}\\
E[\wcm{v}{v'}]          &\rr E[v']\label{wcm-body}\\
E[\ccm]                 &\rr E[\chi(E)]\label{ccm-in-context}
\end{align}

As an extension of \lv, \cm\ inherits rule \ref{reduction} with substitution carried through \scheme'wcm' terms.

If directly-nested \scheme'wcm' directives are introduced into the evaluation context, invalidating it (as in the tail-recursive factorial example), rule \ref{tail-enforce} collapses the outer into the inner.

Rule \ref{wcm-body} defines the value of a \scheme'wcm' expression to take on the value of the body, once obtained.

The definition of rule \ref{ccm-in-context} is given in terms of a metafunction $\chi$ defined by
\begin{equation}
\chi(E)=\chi'(E,\abs{x}{\abs{y}{y}})
\end{equation}
where $\chi'$ is defined by
\begin{align}
\chi'(\wcm{v}{F},vs) &= \chi'(F,\abs{z}{\app{\app{z}{v}}{vs}})\\
\chi'(\app{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\app{v}{E},vs) &= \chi'(E,vs)\\
\chi'(\wcm{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\hole,vs)      &= vs
\end{align}
This definition formalizes the intuition given earlier regarding the behavior of \scheme'ccm'. Previously, we saw that the value of a \scheme'ccm' directive was a list; however, lists do not strictly exist as values in the \lc, nor in our extension. Instead of adding lists as primitive values to \cm, we employ Church-encodings to represent them natively \cite{barendregt1984lambda}.

%The accumulator-passing style definition of $\chi$ has the effect of ordering the marks from most- to least-recently placed.

Let $\lvrr$ denote the reduction relation for \lv\ and $\lvrrs$ its transitive closure. Similarly, let $\cmrr$ denote the reduction relation for \cm\ and $\cmrrs$ its transitive closure. We will use the more specific notation when $\rightarrow$ is potentially ambiguous.

With the source and target languages formally specified, we can now examine a language transformation in earnest.

\setkeyword{cons snd}
\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{e_0}{$e_0$}
\setspecialsymbol{e_0p}{$e'_0$}
\setspecialsymbol{Ce_0}{$\C{e_0}$}
\setspecialsymbol{Ce_0p}{$\C{e'_0}$}
\setspecialsymbol{x_1}{$x_1$}
\setspecialsymbol{x_n}{$x_n$}
\setspecialsymbol{e_1}{$e_1$}
\setspecialsymbol{e_n}{$e_n$}
\setspecialsymbol{k_1}{$k_1$}
\setspecialsymbol{k_2}{$k_2$}
\setspecialsymbol{Ce_1}{$\C{e_1}$}
\setspecialsymbol{Ce_1p}{$\C{e'_1}$}
\setspecialsymbol{Cv}{$\C{v}$}
\setspecialsymbol{v_0}{$v_0$}
\setspecialsymbol{Cv_0}{$\C{v_0}$}
\setspecialsymbol{Cv_0p}{$\C{v'_0}$}
\setspecialsymbol{Cpv_0}{$\Cp{v_0}$}
\setspecialsymbol{Cpv_1}{$\Cp{v_1}$}
\setspecialsymbol{v_1}{$v_1$}
\setspecialsymbol{T}{$\mathcal{A}$}
\setspecialsymbol{C}{$\mathcal{C}$}
\setspecialsymbol{Cp}{$\mathcal{C}'$}
\setspecialsymbol{Ch}{$\hat{\mathcal{C}}$}
\setspecialsymbol{Ccps}{$\mathcal{C}_{\mathrm{cps}}$}
\setspecialsymbol{Cpcps}{$\mathcal{C}'_{\mathrm{cps}}$}
\setspecialsymbol{Chcps}{$\hat{\mathcal{C}}_{\mathrm{cps}}$}
\setspecialsymbol{hole}{$\hole$}
\setspecialsymbol{bottom}{$\perp$}
\setspecialsymbol{Ce_0p_x_Cpv_1}{$\C{e'_0}[x\leftarrow\Cp{v_1}]$}
\setspecialsymbol{e_0p_x_v_1}{$e'_0[x\leftarrow v_1]$}
\setspecialsymbol{Cz}{$\C{z}$}
\setspecialsymbol{CE}{$\C{E}$}
\setspecialsymbol{xiE}{$\xi(E)$}
\setspecialsymbol{chiE}{$\chi(E)$}
\setspecialsymbol{CchiE}{$\C{\chi(E)}$}

\setspecialsymbol{TRUE}{$\mathbf{true}$}
\setspecialsymbol{FALSE}{$\mathbf{false}$}
\setspecialsymbol{PAIR}{$\mathbf{pair}$}
\setspecialsymbol{CONS}{$\mathbf{cons}$}
\setspecialsymbol{FST}{$\mathbf{fst}$}
\setspecialsymbol{SND}{$\mathbf{snd}$}
\setspecialsymbol{NIL}{$\mathbf{nil}$}

\newcommand{\true}{\mathbf{true}}
\newcommand{\false}{\mathbf{false}}
\newcommand{\nil}{\mathbf{nil}}
\newcommand{\cons}[2]{((\mathbf{cons}\,#1)\,#2)}
\newcommand{\eval}[1]{\overline{#1}}

\section{Transformation}
\label{sec-transformation}

As transformations, desugarings put the meaning of one construct in terms of another. If the meaning of the former was given only informally, the desugaring offers a new definition as formal as the definition of the latter. In this way, desugarings offer a convenient way to provide meaning to a construct and avoid enlarging the language. If, however, the sugared language already has a formal meaning, as does \cm, the desugaring must preserve it.

We will define a transformation from \cm\ to \lv\ and term it $\mathcal{C}$, as in \emph{compile}, since we are, in essence, compiling away continuation marks. In order to preserve the meaning of \cm, $\mathcal{C}$ must commute with evaluation. More precisely, for programs $p\in\lambda_{cm}$,
\[
\begin{array}{ccc}
p & \cmrrs & v\\
\downarrow_\mathcal{C} & & \downarrow_\mathcal{C}\\
\C{p} & \lvrrs & \C{v}
\end{array}
\]
should hold, or, more concisely,
\begin{equation}
\label{meaning-preservation-property}
p\cmrrs v\implies\C{p}\lvrrs\C{v}
\end{equation}

If we define 
\begin{equation}
\evalcm{p}=\begin{cases}
v     &\text{if $p\cmrrs v$}\\
\perp &\text{if $p\cmrrs\cdots$}
\end{cases}
\end{equation}
and
\begin{equation}
\evalv{p}=\begin{cases}
v     &\text{if $p\lvrrs v$}\\
\perp &\text{if $p\lvrrs\cdots$}
\end{cases}
\end{equation}
we can state this yet more concisely by $\C{\evalcm{p}}=\evalv{\C{p}}$.

\subsection{Intuition}

The essence of \cm\ is that programs can apply information to and observe information about the context in which they are evaluated. Programs in \lv\ have no such facility. We can simulate this facility by explicitly passing contextual information to each term as it is evaluated. We can define $\mathcal{C}$ to transform \scheme'wcm' directives to manipulate this information and \scheme'ccm' directives to access it. Intuitively, we can transform \cm\ programs to mark-passing style.

However, marks alone do not account for the tail-call behavior specified by rule \ref{tail-enforce}. Since tail-call behavior is observable (if indirectly) by \cm\ programs, we must also provide to each term information about the position in which it is evaluated. Specifically, each transformed \scheme'wcm' directive must be notified whether it is evaluated in tail position of an enclosing \scheme'wcm' directive as it must behave specially if so. Thus, in addition to passing the current continuation marks, the transform should pass a flag to each term indicating whether it is evaluated in tail position of a \scheme'wcm' directive.

%Since this is a dynamic property of the evaluation, we do not attempt to infer it statically.

These two pieces of information suffice to correctly simulate continuation marks.

\subsection{Concept}

The definition of $\mathcal{C}$ entails transformation over each syntactic form of \cm.

With this in mind, consider a conceptual transformation of application, \scheme|C[(rator-expr rand-expr)]|, as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    (let ((rator-value ((C[rator-expr] FALSE) marks))
          (rand-value ((C[rand-expr] FALSE) marks))
      (((rator-value rand-value) flag) marks))))
\end{schemedisplay}
ignoring for the moment that \scheme'let' is in neither \lv\ or \cm. This definition captures that
\begin{enumerate}
\item before evaluation, we expect \scheme'flag' to indicate tail position information and \scheme'marks' to provide a list of the current continuation marks,
\item we would like to evaluate \scheme'C[rator-expr]' and \scheme'C[rand-expr]' in the same manner, providing to each its contextual information--specifically that neither is evaluated in tail position of a \scheme'wcm' directive and the continuation marks for each are unchanged from the parent context,
\item and, following evaluation of operator and operand and application, evaluation of the resultant term is performed with the original contextual information.
\end{enumerate}

Now consider a conceptual transformation of a \scheme'wcm' directive, \scheme|C[(wcm mark-expr body-expr)]|, as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    ((C[body-expr] TRUE) (let ((mark-value ((C[mark-expr] FALSE) marks))
                               (rest-marks (if flag (snd marks) marks)))
                           (cons mark-value rest-marks)))))
\end{schemedisplay}
with similar caveats as the previous case. This definition captures that
\begin{enumerate}
\item as in application, we expect \scheme'flag' to indicate tail position information and \scheme'marks' to provide a list of the current continuation marks,
\item we evaluate \scheme'mark-expr' with correct contextual information,
\item we discard the first continuation mark of the parent context if evaluation is occurring in tail position of a \scheme'wcm' directive,
\item and we evaluate \scheme'C[body-expr]' with the correct tail-position flag and current continuation marks.
\end{enumerate}

Finally, consider the conceptual transformation of a \scheme'ccm' directive, \scheme|C[(ccm)]|, as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    marks))
\end{schemedisplay}
wherein we reap the fruits of simplicity from our laborious passing: this definition is gratifyingly direct.

The conceptual transformation of variables \scheme'x' and values \scheme'(lambda (x) e)' is straightforward.

We now address the absence of \scheme'let', \scheme'if', \scheme'cons', etc. from \lv.

We can express the \scheme'let' construct in \lv\ with application. An expression such as
\begin{schemedisplay}
(let ((x_1 e_1)
      ...
      (x_n e_n))
  e)
\end{schemedisplay}
can be interpreted as
\begin{schemedisplay}
(...((lambda (x_1) ... (lambda (x_n)
           e)...) e_1) ...) e_n)
\end{schemedisplay}
which is the curried form of
\begin{schemedisplay}
((lambda (x_1 ... x_n)
           e) e_1 ... e_n)
\end{schemedisplay}
We use this fact to construct the transformation and apply $\beta$-rule to simplify terms statically.

We use the Church encodings of \scheme'if' and conditionals as well as for list-manipulation operators \scheme{cons}, etc. \cite{barendregt1984lambda}.

\subsection{Initiation}

Abstracting terms has the effect of suspending evaluation. When an entire program is transformed, all evaluation is suspended, and awaits arguments representing contextual information. At the top level, the context is empty, so we pass the contextual information for the empty context: \scheme'FALSE' indicating evaluation is \emph{not} occurring in \scheme'wcm' tail position and \scheme'NIL', an empty list of marks.

We can accommodate this by defining a top-level transform $\hat{\mathcal{C}}$ in terms of $\mathcal{C}$ by
\begin{equation}
\Ch{p}=\app{\app{\C{p}}{\false}}{\nil}
\end{equation}

and stating our commutativity property as
\begin{equation}
\Ch{\evalcm{p}}=\evalv{\Ch{p}}
\end{equation}
which is equivalent to
\begin{equation}
\app{\app{\C{\evalcm{p}}}{\false}}{\nil}=\evalv{\app{\app{\C{p}}{\false}}{\nil}}
\end{equation}

\subsection{Some final subtleties}

Our choice to keep the core language small by omitting lists as primitive values has the consequence of complicating our transform somewhat. Because lists are defined in terms of \lc\ values which are themselves touched by the transform and because of the commutativity property that $\mathcal{C}$ must satisfy, we cannot deal with a list of continuation marks directly--we must instead deal with a transformed list of transformed continuation marks, and manipulation of this list within transformed terms must occur at the transformed level.

Additionally, after evaluation, values are ``truncated'' with their leading abstractions applied away. For instance, the transformation of the value \scheme|(lambda (x) x)| to \scheme|(lambda (flag) (lambda (marks) (lambda (x) (lambda (flag) (lambda (marks) x)))))| will yield, following evaluation, \scheme|(lambda (x) (lambda (flag) (lambda (marks) x)))|. For convenience, we define 
\begin{equation}
\Cp{\abs{x}{e}}=\abs{x}{\C{e}}
\end{equation}
and we adjust $\hat{\mathcal{C}}$ so that
\begin{equation}
\Ch{p}=\app{\app{\C{p}}{\false}}{\Cp{\nil}}
\end{equation}


\newenvironment{schemedefn}[1]{\begin{plaindef}#1}{\end{plaindef}}
\newenvironment{namedschemedefn}[2]{\begin{plaindef}\label{#1}$#2$}{\end{plaindef}}

\subsection{Definition of $\mathcal{C}$}

The definition of $\mathcal{C}$ over the five syntactic forms of \cm\ follows. For reference, figure \ref{church-encodings} contains the particular Church encodings of relevant terms.

\begin{figure}
\label{church-encodings}
\begin{align*}
\true         &= \abs{x}{\abs{y}{x}}\\
\false        &= \abs{x}{\abs{y}{y}}\\
\mathbf{cons} &= \abs{a}{\abs{b}{\abs{z}{\app{\app{z}{a}}{b}}}}\\
\mathbf{snd}  &= \abs{p}{\app{p}{\false}}\\
\nil          &= \false
\end{align*}
\caption{Church encodings of booleans and lists}
\end{figure}

The formal transformation of application follows the \scheme'let' version exactly except the definitions of \scheme'rator-value' and \scheme'rand-value' are folded directly in.

\begin{schemedefn}{\scheme|C[(rator-expr rand-expr)]|}
\begin{schemedisplay}
(lambda (flags)
  (lambda (marks)
    (((((C[rator-expr] FALSE) marks)
       ((C[rand-expr] FALSE) marks))
      flags)
     marks)))
\end{schemedisplay}
\end{schemedefn}

The formal transformation of a \scheme'wcm' directive is also extremely similar to the \scheme'let' version. The definition of \scheme'C[cons]' is unfolded and simplified.

\begin{schemedefn}{\scheme|C[(wcm mark-expr body-expr)]|}
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    ((C[body-expr] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       ((C[mark-expr] FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))
\end{schemedisplay}
\end{schemedefn}

%The definition over \scheme'wcm' expressions is the only one to make explicit use of the value of the flag. Following the evaluation of the mark expression, rule \ref{tail-enforce} is applied, if necessary. The continuity of $\chi$ allows us to construct $\chi(E''[\wcm{v_0}{e_1}])$ from $\chi(E)$ where 

%\begin{equation}
%E''=\begin{cases}
%E' &\text{if $E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}\\
%E &\text{otherwise}
%\end{cases}
%\end{equation}

The \scheme'let' version of the transformation of a \scheme'ccm' directive remains unchanged.

\begin{schemedefn}{\scheme|C[(ccm)]|}
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    marks))
\end{schemedisplay}
\end{schemedefn}

Like other terms, values are modified to receive contextual information. However, it is ignored.
% we use this fact a bit

\begin{schemedefn}{\scheme|C[v]|=\scheme|C[(lambda (x) e)]|}
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    (lambda (x) C[e])))
\end{schemedisplay}
\end{schemedefn}

% Variables have the property that, when substitution occurs, they reconstitute values.

\begin{schemedefn}{\scheme|C[x]|}
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    x))
\end{schemedisplay}
\end{schemedefn}

\subsection{CPS transformation}

The use of continuation-passing style as a compiler's intermediate language enables a host of optimization analyses, such as dead-code elimination, and makes the implementation of otherwise-heavyweight features trivial, such as first-class continuations \cite{appel2007compiling}.

We present a continuation mark transformation integrated in continuation-passing style.

\begin{schemedefn}{\scheme|Ccps[(rator-expr rand-expr)]|}
\begin{schemedisplay}
(lambda (kont)
   (lambda (flag)
     (lambda (marks)
       (((Ccps[rator-expr]
          (lambda (rator-value)
            (((Ccps[rand-expr]
               (lambda (rand-value)
                 ((((rator-value rand-value) kont) flag) marks)))
              FALSE)
             marks)))
         FALSE)
        marks))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|C[(wcm mark-expr body-expr)]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (((Ccps[mark-expr]
          (lambda (mark-value) 
            ((lambda (rest-marks) 
               (((Ccps[body-expr] kont) TRUE) (lambda (z) C[((z mark-value) rest-marks)])))
             ((flag Ch_cps[(SND marks)]) marks))))
        FALSE)
       marks))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|Ccps[(ccm)]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (kont marks))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|Ccps[v]|=\scheme|Ccps[(lambda (x) e)]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (kont (lambda (x) Ccps[e])))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|Ccps[x]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (kont x))))
\end{schemedisplay}
\end{schemedefn}

We include corresponding definitions for $\mathcal{C}'$ and $\hat{\mathcal{C}}$.

\begin{schemedefn}{\scheme|Cpcps[(lambda (x) e)]|}
\begin{schemedisplay}
(lambda (x) Ccps[e])
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|Chcps[p]|}
\begin{schemedisplay}
(((Ccps[p] (lambda (x) x)) FALSE) Cpcps[nil])
\end{schemedisplay}
\end{schemedefn}

\subsection{Example}

Consider the \cm\ program \scheme|(wcm 0 ((lambda (x) (wcm x (ccm))) 1))| which reduces as
\begin{schemedisplay}
(wcm 0 ((lambda (x) (wcm x (ccm))) 1))
(wcm 0 (wcm 1 (ccm)))
(wcm 1 (ccm))
(wcm 1 (lambda (z) ((z 1) (lambda (x) (lambda (y) y)))))
(lambda (z) ((z 1) (lambda (x) (lambda (y) y))))
\end{schemedisplay}
and transforms as
\begin{schemedisplay}
Ch[(wcm 0 ((lambda (x) (wcm x (ccm))) 1))]
((C[(wcm 0 ((lambda (x) (wcm x (ccm))) 1))] FALSE) Cp[NIL])
(((lambda (flag)
  (lambda (marks)
    ((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       ((C[0] FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))
 FALSE)
Cp[NIL])
(((lambda (flag)
  (lambda (marks)
    ((C[(lambda (flags)
  (lambda (marks)
    (((((C[(lambda (x) (wcm x (ccm)))] FALSE) marks)
       ((C[1] FALSE) marks))
      flags)
     marks)))] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       (((lambda (flag) (lambda (marks) 0)) FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))
 FALSE)
Cp[NIL])
(((lambda (flag)
  (lambda (marks)
    ((C[(lambda (flags)
  (lambda (marks)
    ((((((lambda (flag)
           (lambda (marks)
             (lambda (x)
               C[(wcm x (ccm))]))) FALSE) marks)
       (((lambda (flag) (lambda (marks) 1)) FALSE) marks))
      flags)
     marks)))] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       (((lambda (flag) (lambda (marks) 0)) FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))
 FALSE)
Cp[NIL])
(((lambda (flag)
  (lambda (marks)
    ((C[(lambda (flags)
  (lambda (marks)
    ((((((lambda (flag)
           (lambda (marks)
             (lambda (x)
               (lambda (flag)
  (lambda (marks)
    ((C[(ccm)] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       ((C[x] FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))))) FALSE) marks)
       (((lambda (flag) (lambda (marks) 1)) FALSE) marks))
      flags)
     marks)))] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       (((lambda (flag) (lambda (marks) 0)) FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))
 FALSE)
Cp[NIL])

(((lambda (flag)
  (lambda (marks)
    ((C[(lambda (flags)
  (lambda (marks)
    ((((((lambda (flag)
           (lambda (marks)
             (lambda (x)
               (lambda (flag)
  (lambda (marks)
    (((lambda (flag) (lambda (marks) marks)) TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       (((lambda (flag) (lambda (marks) x)) FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))))) FALSE) marks)
       (((lambda (flag) (lambda (marks) 1)) FALSE) marks))
      flags)
     marks)))] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) (lambda (z) C[((z mark-value) rest-marks)])))
       (((lambda (flag) (lambda (marks) 0)) FALSE) marks))
      ((flag Cp[(SND marks)]) marks)))))
 FALSE)
Cp[NIL])
\end{schemedisplay}

[This example is way too long. Are trivial examples generally uninteresting?]

% TODO
%explain transforms for values and variables
%fix references
%add example program
%fix introduction and handling of CPS
%talk about proof
%fix conclusion


\section{Testing}
\label{sec-testing}

A pragmatic approach to the discovery of a correct transformation involves consistent feedback and testing to validate candidate transforms. Testing is no substitute for proof, but, as Klein et al. \cite{klein2012run} show, proof is no substitute for testing. Lightweight mechanization is a fruitful middle ground between pencil-and-paper analysis and fully-mechanized formal proof. We use Redex \cite{findler2010redex}, a domain-specific language for exploring language semantics, to provide feedback, thoroughly exercise candidates, and perform exploratory analysis.

The correctness of the transform lies in the property that it commutes. In order to test for this property, we must construct evaluation models for the source language \cm\ and the target language \lv. Since \cm\ is an extension of \lv, many of its forms and semantics are inherited. Redex allows us to exploit this fact by defining a model for \lv\ first and then extending that model with the enhancements of \cm.

\setkeyword{define-language define-extended-language define-metafunction reduction-relation extend-reduction-relation define-metafunction/extension in-hole hole variable-not-otherwise-mentioned}
\setkeyword{wcm ccm}

\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{->}{$\to$}
\setspecialsymbol{-->}{$\rightarrow$}
\setspecialsymbol{betav}{$\beta$v}
\setconstant{error}
\setkeyword{chi chi_p number apply-reduction-relation*}

\setspecialsymbol{lambdav}{$\lambda$v}
\setspecialsymbol{lambdav-rr}{$\lambda$v-rr}
\setspecialsymbol{lambdav-subst}{$\lambda$v-subst}

We first define the form of terms $e$, values $v$, and evaluation contexts $E$.

\begin{schemedisplay}
(define-language lambdav
  (e (e e) x v error)
  (x variable-not-otherwise-mentioned)
  (v (lambda (x) e) number)
  (E (E e) (v E) hole))
\end{schemedisplay}

We then define the reduction relation for \lv. It consists of five rules. The first rule captures the sole semantic rule of \lv; the remaining handle error conditions.

\begin{schemedisplay}
(define lambdav-rr
  (reduction-relation lambdav
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdav-subst x v e))
        "betav")
   (--> (in-hole E (number_1 v))
        (in-hole E error)
        "error: number in operator position")
   (--> (in-hole E x)
        (in-hole E error)
        "error: unbound identifier")
   (--> (in-hole E (error e))
        (in-hole E error)
        "error in operator")
   (--> (in-hole E (v error))
        (in-hole E error)
        "error in operand")))
\end{schemedisplay}

The reduction relation requires one metafunction to perform substitution. We omit any capture-avoidance facilities to keep the model simple and argue that it is unnecessary as we generate fresh variables in the transform.

\begin{schemedisplay}
(define-metafunction lambdav
  lambdav-subst : x v e -> e
  ;; 1. substitute in application
  [(lambdav-subst x_1 v_1 (e_1 e_2))
   ((lambdav-subst x_1 v_1 e_1) (lambdav-subst x_1 v_1 e_2))]
  ;; 2a. substitute in variable (same)
  [(lambdav-subst x_1 v_1 x_1)
   v_1]
  ;; 2b. substitute in variable (different)
  [(lambdav-subst x_1 v_1 x_2)
   x_2]
  ;; 3a. substitute in abstraction (bound)
  [(lambdav-subst x_1 v_1 (lambda (x_1) e_1))
   (lambda (x_1) e_1)]
  ;; 3b. substitute in abstraction (free)
  [(lambdav-subst x_1 v_1 (lambda (x_2) e_1))
   (lambda (x_2) (lambdav-subst x_1 v_1 e_1))]
  ;; 4. substitute in number
  [(lambdav-subst x_1 v_1 number_1)
   number_1]
  ;; 5. substitute in error
  [(lambdav-subst x_1 v_1 error)
   error])
\end{schemedisplay}

\setspecialsymbol{lambdacm}{$\lambda$cm}
\setspecialsymbol{lambdacm-rr}{$\lambda$cm-rr}
\setspecialsymbol{lambdacm-subst}{$\lambda$cm-subst}

We now define the forms of terms $e$, and evaluation contexts $E$ and $F$, inheriting definitions from \lv\ where appropriate.

\begin{schemedisplay}
(define-extended-language lambdacm lambdav
  (e .... (wcm e e) (ccm))
  (E (wcm v F) F)
  (F (E e) (v E) (wcm E e) hole))
\end{schemedisplay}

We extend the reduction relation of \lv. We begin by redefining application in terms of a substitution function aware of \cm. The following three definitions capture the remaining semantic rules of \cm. The remaining definitions handle error cases specific to \cm.

\begin{schemedisplay}
(define lambdacm-rr
  (extend-reduction-relation lambdav-rr lambdacm
   (--> (in-hole E ((lambda (x) e) v))
        (in-hole E (lambdacm-subst x v e))
        "betav")
   (--> (in-hole E (wcm v_1 (wcm v_2 e)))
        (in-hole E (wcm v_2 e))
        "wcm-collapse")
   (--> (in-hole E (wcm v_1 v_2))
        (in-hole E v_2)
        "wcm")
   (--> (in-hole E (ccm))
        (in-hole E (chi E))
        "chi")
   (--> (in-hole E (wcm error e))
        (in-hole E error)
        "error in wcm mark expression")
   (--> (in-hole E (wcm v error))
        (in-hole E error)
        "error in wcm body expression")))
\end{schemedisplay}

We extend the definition of substitution to accommodate the additional forms introduced by \cm.

\begin{schemedisplay}
(define-metafunction/extension lambdav-subst lambdacm
  lambdacm-subst : x v e -> e
  ;; 1. substitute in wcm form
  [(lambdacm-subst x_1 v_1 (wcm e_1 e_2))
   (wcm (lambdacm-subst x_1 v_1 e_1) (lambdacm-subst x_1 v_1 e_2))]
  ;; 2. substitute in ccm form
  [(lambdacm-subst x_1 v_1 (ccm))
   (ccm)])
\end{schemedisplay}

The definition of \scheme'chi' and \scheme'chi_p' mirror their definitions exactly.

\begin{schemedisplay}
(define-metafunction lambdacm
  chi : E -> v
  [(chi E) (chi_p E (lambda (x) (lambda (y) y)))])

(define-metafunction lambdacm
  chi_p : E v -> v
  [(chi_p hole v_ms)      v_ms]
  [(chi_p (E e) v_ms)     (chi_p E v_ms)]
  [(chi_p (v E) v_ms)     (chi_p E v_ms)]
  [(chi_p (wcm E e) v_ms) (chi_p E v_ms)]
  [(chi_p (wcm v E) v_ms) (chi_p E (lambda (p) ((p v) v_ms)))])
\end{schemedisplay}

We are now prepared to test various semantic properties of these two languages. Of course, we are particularly interested in testing the commutativity of our transformation.

%We observe that a mark-passing approach, much like a continuation-passing approach, abstracts terms and so requires a transformed term to be primed with an argument to initiate reduction. For this reason, we accompany each transform with an initialization function which primes a term appropriately for the corresponding transform.

\setkeyword{meaning-preserved? alpha-eq? transform eval init redex-check}

We can test that the property described by equation \ref{meaning-preservation-property} holds for a given program \scheme'p' with 
\begin{schemedisplay}
(define (meaning-preserved? p)
  (alpha-eq? (eval lambdav (transform (eval lambdacm p))) (eval lambdav (transform p)))
\end{schemedisplay}
where \scheme'alpha-eq?' determines $\alpha$-equivalence between two \lc\ terms and \scheme'eval' is an alias for the Redex native \scheme'apply-reduction-relation*'.

Redex provides convenient functions to initiate random testing.

\begin{schemedisplay}
(redex-check lambdacm e (meaning-preserved? e))
\end{schemedisplay}

\scheme'redex-check' generates random terms according to the grammar of the given language (\scheme'lambdacm') and category (\scheme'e') in search of counterexamples to the predicate. It gradually increases the size of the terms it generates, which we found useful in obtaining minimal test cases. Once the transformation withstood 10,000 random tests, we considered it for proof (though no incorrect transform withstood more than 500).

\section{Proof}
\label{sec-proof}

The theorem we prove guarantees the same property we have strived to preserve: commutativity. Formally, we would like to prove the correctness of $\hat{\mathcal{C}}$.

%\spnewtheorem*{maintheoremeu}{Correctness of $\hat{\mathcal{C}}$}{a}{x}
\begin{theorem}
For all programs $p\in\lambda_{cm}$, $\Ch{\mathrm{eval}_{cm}(p)}=\mathrm{eval}_{v}(\Ch{p})$.
\end{theorem}

We do this by overloading $\mathcal{C}$ to accommodate contexts which allows us to formally relate $E[e]$ and $\C{E[e]}$.

This in turn allows us to express the following lemmas.

\begin{lemma}
For all contexts $E$ and terms $e$, $E[e]\cmrrs v\implies\C{E[e]}\lvrrs\Cp{v}$.
\end{lemma}

To accomplish this, we first prove by structural induction that for all terms $e$ and context $E$ arbitrary but fixed, $E[e]\cmrrs E[v]\implies\C{E[e]}\lvrrs\C{E[v]}$. 

We then prove that for all contexts $E$, $E[v]\cmrrs v'\implies\C{E[v]}\lvrrs\Cp{v'}$.

The theorem follows.

\section{Back to JavaScript}
\label{sec-javascript}

With a correct transformation of continuation marks defined over the \lc, little effort is required to add continuation marks to an eager, higher-order language such as JavaScript.

We add two keywords to manipulate continuation marks: the familiar \texttt{wcm} and \texttt{ccm}. We chose block syntax for \texttt{wcm} to convey that it is a special form, like a conditional, instead of a function-like interface. A lone \texttt{ccm} evaluates to the current continuation marks.

Tail-call elimination is not part of the JavaScript specification which complicates the treatment of the tail-call behavior. We have chosen to perform a simple static analysis which determines if the recursive call is in tail position. We simulate proper tail-call behavior by assigning the static value of the flag to reflect this.

A properly-recursive factorial can be implemented in this JavaScript extension as
\begin{verbatim}
var fac = function( n ) {
  if( n == 0 ) {
    console.log( ccm );
    return 1;
  }
  else {
    return wcm { n }
               { n * fac( n - 1 ) };
  }
}
\end{verbatim}

A transformation of this function desugars these constructs into vanilla JavaScript, leveraging native arrays for lists of continuation marks.
\begin{verbatim}
var fac = function( flag, marks ) {
  return function( n ) {
    if( n == 0 ) {
      console.log( (function( flag, marks ) { return marks; })( false, marks ) );
      return 1;
    }
    else {
      return (function( flag, marks ) {
        return (function( mark_value, rest_marks ) {
          return n * fac( false, [ mark_value ].concat( rest_marks ) )( n - 1 );
        })( n, flag ? marks.slice( 1 ) : marks );
      })( flag, marks );
    }
  }
}
\end{verbatim}

As expected, the output of a manual initiation of this function is
\begin{verbatim}
> fac( false, [] )( 5 )
[ 1, 2, 3, 4, 5 ]
120
\end{verbatim}

A tail-recursive factorial is expressible in this extension as
\begin{verbatim}
var fac = function( n, acc ) {
  if( n == 0 ) {
    console.log( ccm );
    return acc;
  }
  else {
    return wcm { n }
               { fac( n - 1, n * acc ) };
  }
}
\end{verbatim}
and transforms to
\begin{verbatim}
var fac = function( flag, marks ) {
  return function( n, acc ) {
    if( n == 0 ) {
      console.log( (function( flag, marks ) { return marks; })( false, marks ) );
      return acc;
    }
    else {
      return (function( flag, marks ) {
        return (function( mark_value, rest_marks ) {
          return fac( true, [ mark_value ].concat( rest_marks ) )( n - 1, n * acc );
        })( n, flag ? marks.slice( 1 ) : marks );
      })( flag, marks );
    }
  }
}
\end{verbatim}

The output of a manual initiation of this function is
\begin{verbatim}
> fac( false, [] )( 5, 1 )
[ 1 ]
120
\end{verbatim}

\section{Future Work}

Although we used some level of mechanization in the proof of the theorem, a formal proof assistant, such as Coq \cite{barras1997coq}, would increase confidence out of the gate that the transformation was correct.

\section{Conclusion}

Continuation marks support a bevy of instrumentation tools and advanced language features in a generalized, portable way. Despite their demonstrated utility, they have not yet found their way into most languages. A verified characterization of continuation marks in a pure computational language provides implementors of higher-order languages a correct compiler for continuation marks.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}
