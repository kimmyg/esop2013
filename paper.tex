\documentclass{llncs}

\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{slatex}
\usepackage{listings}


\title{Instant Continuation Marks--Just Add $\lambda$}

\author{Kimball Germane \and Jay McCarthy}
\institute{Brigham Young University, Provo, Utah}

% Look at the many other papers on c marks to justify them (see mine for
% example). Talk about how your transformation is a compiler and right
% now no language but Racket has C-marks, so we could use this to get
% them in that language. For Racket though, now they don't need to be
% built in to the compiler if we don't want. In addition, it makes it
% easier to do a type system.

\spnewtheorem{plaindef}{Definition}{\bfseries}{\rmfamily}

\setkeyword{wcm ccm with-continuation-mark current-continuation-marks}
\setkeyword{print fac zero?}

\newcommand{\cm}[0]{$\lambda_{cm}$}
\newcommand{\lv}[0]{$\lambda_v$}
\newcommand{\lc}[0]{$\lambda$-calculus}
\newcommand{\wcm}[2]{(\mathrm{wcm}\,#1\,#2)}
\newcommand{\ccm}[0]{(\mathrm{ccm})}
\newcommand{\wcmb}[2]{(\mathbf{wcm}\,#1\,#2)}
\newcommand{\ccmb}[0]{(\mathbf{ccm})}
\newcommand{\app}[2]{(#1\,#2)}
\newcommand{\abs}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\hole}[0]{\bullet}
\newcommand{\rr}[0]{\rightarrow}
\newcommand{\lrrs}[0]{\rightarrow^{*}}
\newcommand{\lvrr}[0]{\rightarrow_v}
\newcommand{\lvrrs}[0]{\rightarrow_v^{*}}
\newcommand{\cmrr}[0]{\rightarrow_{cm}}
\newcommand{\cmrrs}[0]{\rightarrow_{cm}^{*}}
\newcommand{\C}[1]{\mathcal{C}[#1]}
\newcommand{\Cp}[1]{\mathcal{C}'[#1]}
\newcommand{\Ch}[1]{\hat{\mathcal{C}}[#1]}
\newcommand{\Ccps}[1]{\mathcal{C}_{\mathrm{cps}}[#1]}
\newcommand{\Cpcps}[1]{\mathcal{C}'_{\mathrm{cps}}[#1]}
\newcommand{\Chcps}[1]{\hat{\mathcal{C}}_{\mathrm{cps}}[#1]}
\newcommand{\evalv}[1]{\mathrm{eval}_v(#1)}
\newcommand{\evalcm}[1]{\mathrm{eval}_{cm}(#1)}

\begin{document}

\maketitle

\begin{abstract}
Continuation marks are a programming language feature which generalizes stack inspection. Despite its usefulness, this feature has not been adopted by languages which rely on stack inspection, e.g., for dynamic security checks. One reason for this neglect may be that continuation marks do not yet enjoy a transformation to the plain $\lambda$-calculus which would allow higher-order languages to provide continuation marks at little cost.

We present direct and CPS-like transformations from the call-by-value $\lambda$-calculus augmented with continuation marks to the pure call-by-value $\lambda$-calculus. We discuss how such transformations simplify the construction of compilers which treat continuation marks correctly. We document how Redex, a domain-specific language for exploring language semantics, aided the discovery of correct transformations. We verify the transformations with the proof of a meaning-preservation theorem. Finally, we apply the transformation to JavaScript.
\end{abstract}

\section{Introduction}

Numerous programming language instruments rely on stack inspection to function. Statistical profilers sample the stack regularly to record active functions, algebraic steppers observe the stack to represent the evaluation context of an expression, and debuggers naturally require consistent access to the stack. In each of these scenarios, the instrument relies on implementation-specific information and must be maintained as the instrumented language undergoes optimizations and ventures across platforms. This makes these instruments brittle and increases the porting cost of the language ecosystem. Each would benefit from a generalized stack-inspection mechanism available within the instrumented language itself. If written in such an enhanced language, each instrument would be more robust, more easily modified, and would port for free.

Continuation marks \cite{clements2006portable} are a programming language feature which generalizes stack inpection. Not only do they dramatically simplify correct instrumentation \cite{clements2001modeling}, they have been used to allow inspection-based dynamic security checks in the presence of tail-call optimization \cite{clements2004tail}, to express aspect-oriented programming in higher-order languagues \cite{tucker2003pointcuts}, and to implement a form of dynamic binding in parameters.

Continuation marks originated in PLT Scheme (now Racket \cite{plt-tr1}). However, in spite of their usefulness, continuation marks have remained absent from programming languages at large. One reason for this is that retrofitting virtual machines to accommodate the level of stack inspection continuation marks must provide is expensive, especially when the virtual machines use the host stack for efficiency.

For example, the ubiquitous JavaScript is an ideal candidate for the addition of continuation marks. However, as the lingua franca of the web, it has numerous mature implementations which have been heavily optimized. To add continuation marks to JavaScript amounts to modifying each implementation upstream, to say nothing of amending the JavaScript standard. (Clements et al. successfully added continuation marks in Mozilla's Rhino compiler \cite{clements2008implementing}, but it remains a proof-of-concept.)

To avoid this roadblock, we instead take a macro-style approach; that is, we enhance the core language with facilities to manipulate continuation marks and desugar the enhanced language back to the core. To make our desugaring transformation portable to other languages, we define it over the \lc, the common core of most higher-order languages. With such a transformation, language semanticists do not need to reconcile the feature with other features in the language (provided they have already done so with $\lambda$) and their compiler writers do not need to worry about complicating their implementations (for the same reason).

We begin by further explaining continuation marks in section \ref{sec-continuation-marks}. We then formalize them via the introduction of a core and enhanced language in section \ref{sec-core-and-extension}. We discuss the necessary properties of a meaningful transformation between these languages. We present two transformations of continuation marks--one direct and one CPS-like--to the call-by-value \lc\ in section \ref{sec-transformation}. This is followed by randomized testing using a lightweight mechanized model in section \ref{sec-testing} and a proof of a meaning-preservation theorem in section \ref{sec-proof}. We finally apply it to JavaScript in section \ref{sec-javascript}.

\section{Continuation Marks}
\label{sec-continuation-marks}

Continuation marks allow the program to annotate and observe the stack (or continuation). This is accomplished via two surface-level syntactic forms in the language: \scheme'with-continuation-mark', abbreviated \scheme'wcm'; and \scheme'current-continuation-marks', abbreviated \scheme'ccm'.

A \scheme'wcm' expression of the form \scheme|(wcm mark-expr body-expr)| annotates the youngest portion of the continuation with \scheme'mark-value', the evaluation of \scheme'mark-expr', before evaluating \scheme'body-expr' to \scheme'body-value'. If an annotation, or \emph{mark}, already exists on the youngest portion, it is replaced by the new mark. This newly-added mark is available within \scheme'body-expr' via \scheme'ccm' during its evaluation. Once complete, the entire \scheme'wcm' expression takes on \scheme'body-value'.

A \scheme'ccm' expression of the form \scheme|(ccm)| traverses the continuation accumulating a list of annotations ascending in age.

\subsection{Example}

The traditional, properly-recursive factorial function can be expressed with continuation marks as follows:
\begin{schemedisplay}
(define (fac n)
  (if (zero? n)
      (begin
        (print (ccm))
        1)
      (wcm n (* n (fac (- n 1))))))
\end{schemedisplay}
In this definition, a multiplication pends following the recursive call, so the continuation grows with each.

The evaluation of the factorial of 2, expressed by \scheme|(fac 2)|, proceeds as
\begin{schemedisplay}
(fac 2)
(if (zero? 2) ... (wcm 2 (* 2 (fac (- 2 1)))))
(wcm 2 (* 2 (fac (- 2 1))))
(wcm 2 (* 2 (fac 1)))
(wcm 2 (* 2 (if (zero? 1) ... (wcm 1 (* 1 (fac (- 1 1)))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac (- 1 1))))))
(wcm 2 (* 2 (wcm 1 (* 1 (fac 0)))))
(wcm 2 (* 2 (wcm 1 (* 1 (if (zero? 0) (begin (print (ccm)) 1) ...)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print (ccm)) 1)))))
\end{schemedisplay}
At this point, the term \scheme|(ccm)| is evaluated. This happens, in effect, by walking the continuation and building a list of the current continuation marks which appear in the \scheme'mark-value' position of a \scheme'wcm' term. In this example, \scheme|(ccm)| evaluates to \scheme|'(1 2)|. Evaluation continues as
\begin{schemedisplay}
(wcm 2 (* 2 (wcm 1 (* 1 (begin (print '(1 2)) 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 (begin 1)))))
(wcm 2 (* 2 (wcm 1 (* 1 1))))
(wcm 2 (* 2 (wcm 1 1)))
(wcm 2 (* 2 1))
(wcm 2 2)
2
\end{schemedisplay}
The visible effect of the call is
\begin{verbatim}
> (fac 2)
(1 2)
2
\end{verbatim}

In a tail-call optimized language, a call made in tail position does not enlarge the continuation. Instead, the portion of the evaluation context dedicated to the calling function is repurposed for the called function. Continuation marks are also subject to this optimization; if the continuation is marked in tail position, the previous mark there is replaced, if it exists.

This behavior is apparent in the tail-recursive definition of the factorial function, which follows.
\begin{schemedisplay}
(define (fac n acc)
  (if (zero? n)
      (begin
        (print (ccm))
        acc)
      (wcm n (fac (- n 1) (* n acc)))))
\end{schemedisplay}
In this definition, the multiplication is performed before the recursive call and an accumulated value is passed. With no pending computation, the evaluation context devoted to this function is no longer necessary, and is subsumed by the continuation mark directive.

The evaluation of the factorial of 2, here expressed by \scheme|(fac 2 1)|, proceeds as
\begin{schemedisplay}
(fac 2 1)
(if (zero? 2) ... (wcm 2 (fac (- 2 1) (* 2 1))))
(wcm 2 (fac (- 2 1) (* 2 1)))
(wcm 2 (fac 1 (* 2 1)))
(wcm 2 (fac 1 2))
(wcm 2 (if (zero? 1) ... (wcm 1 (fac (- 1 1) (* 1 2)))))
(wcm 2 (wcm 1 (fac (- 1 1) (* 1 2))))
\end{schemedisplay}
At this point, there is one \scheme'wcm' directive directly nested within another. Behaviorally, the outer one is collapsed \emph{before} evaluation of the inner body proceeds. In essence, it is overwritten. Following this, evaluation continues as
\begin{schemedisplay}
(wcm 1 (fac (- 1 1) (* 1 2)))
(wcm 1 (fac 0 (* 1 2)))
(wcm 1 (fac 0 2))
(wcm 1 (if (zero? 0) (begin (print (ccm)) 2) ...))
(wcm 1 (begin (print (ccm)) 2))
(wcm 1 (begin (print '(1)) 2))
(wcm 1 (begin 2))
(wcm 1 2)
2
\end{schemedisplay}
The visible effect of the call is
\begin{verbatim}
> (fac 2 1)
(1)
2
\end{verbatim}
from which the overwriting which occurred is evidenced the singleton list obtained by \scheme|(ccm)|.

Using this mechanism, the principal onus of a statistical profiler, algebraic stepper, or debugger can be met by a straightforward language transformation which recursively wraps each term in a \scheme'wcm' directive annotating the continuation with a description of the wrapped term.

With this understanding of continuation marks, we can now formalize them behaviorally.

\section{Language Core and Extension}
\label{sec-core-and-extension}

In order to formalize continuation marks, we introduce an extension of the \lc\ with facilities to manipulate continuation marks and present its semantics in the style of Felleisen and Hieb \cite{felleisen1992revised}. Because our ultimate goal is a desugaring transform, we first introduce the target language of the transform, the \lc, in the same way.

\subsection{\lv}

The target language of the transform is Plotkin's call-by-value \lc, \lv\ \cite{plotkin1975call}, augmented with natural numbers.

Terms $e$ in \lv\ are the familiar terms of the \lc, defined by
\begin{equation}
e=\app{e}{e}\,|\,v\,|\,x
\end{equation}
where 
\begin{equation}
v=\abs{x}{e}\,|\,n
\end{equation}
with $n\in\mathbb{N}$.

The evaluation model of \lv\ requires a definition of evaluation contexts. We define evaluation contexts $E$ by
\begin{equation}
E=\app{E}{e}\,|\,\app{v}{E}\,|\,\hole
\end{equation}
where $\hole$ denotes a ``hole'' in the evaluation context, the ultimate destination of the evaluation of the expression that previously resided there.

The reduction relation of \lv\ is defined simply by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]
\end{align}
where $e[x\leftarrow v]$ denotes a capture-avoiding substitution of every free occurrence of $x$ in $e$ with $v$.

\subsection{\cm}

The source language of the transformation is an extension of \lv\ with facilities for continuation marks which we term \cm.

Because \cm\ is an extension of \lv, the definition of terms $e$ in \cm\ 
\begin{equation}
e=\wcm{e}{e}\,|\,\ccm\,|\,\app{e}{e}\,|\,v\,|\,x
\end{equation}
is identical to that of \lv\ with the addition of two forms for manipulating continuation marks: \scheme'wcm', short for \scheme'with-continuation-mark', which annotates the continuation with the evaluation of the given mark expression; and \scheme'ccm', short for \scheme'current-continuation-marks', which retrieves the current continuation marks.

The sole novelty of \cm\ above the plain \lv\ is the ability to annotate and observe the continuation. Our evaluation model of \cm, given by Pettyjohn et al. \cite{pettyjohn2005continuations}, utilizes the current evaluation context for that purpose. Evaluation contexts $E$ are defined by
\begin{align}
E=\, &\wcm{v}{F}\,|\,F\\
F=\, &\app{E}{e}\,|\,\app{v}{E}\,|\,\wcm{E}{e}\,|\,\hole
\end{align}
The definition of $E$ is crafted to prevent directly nested \scheme'wcm' directives from occurring in valid evaluation contexts.

The reduction relation of \cm\ is defined by
\begin{align}
E[\app{\abs{x}{e}}{v}]  &\rr E[e[x\leftarrow v]]\label{reduction}\\
E[\wcm{v}{\wcm{v'}{e}}] &\rr E[\wcm{v'}{e}]\label{tail-enforce}\\
E[\wcm{v}{v'}]          &\rr E[v']\label{wcm-body}\\
E[\ccm]                 &\rr E[\chi(E)]\label{ccm-in-context}
\end{align}

As an extension of \lv, \cm\ inherits rule \ref{reduction} with substitution carried through \scheme'wcm' terms.

If directly-nested \scheme'wcm' directives are introduced into the evaluation context, invalidating it (as in the tail-recursive factorial example), rule \ref{tail-enforce} collapses the outer into the inner.

Rule \ref{wcm-body} defines the value of a \scheme'wcm' expression to take on the value of the body, once obtained.

The definition of rule \ref{ccm-in-context} is given in terms of a metafunction $\chi$ defined by
\begin{equation}
\chi(E)=\chi'(E,\abs{x}{\abs{y}{y}})
\end{equation}
where $\chi'$ is defined by
\begin{align}
\chi'(\wcm{v}{F},vs) &= \chi'(F,\abs{z}{\app{\app{z}{v}}{vs}})\\
\chi'(\app{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\app{v}{E},vs) &= \chi'(E,vs)\\
\chi'(\wcm{E}{e},vs) &= \chi'(E,vs)\\
\chi'(\hole,vs)      &= vs
\end{align}
This definition formalizes the intuition given earlier regarding the behavior of \scheme'ccm'. Previously, we saw that the value of a \scheme'ccm' directive was a list; however, lists do not strictly exist as values in the \lc, nor in our extension. Instead of adding lists as primitive values to \cm, we employ Church encodings to represent them natively \cite{barendregt1984lambda}. To keep things clear, we preserve the intention of Church-encoded terms by representing them with the useful shorthand of fig. \ref{church-encodings}.

\setkeyword{cons snd nil}
\setspecialsymbol{lambda}{$\lambda$}
\setspecialsymbol{e_0}{$e_0$}
\setspecialsymbol{e_0p}{$e'_0$}
\setspecialsymbol{Ce_0}{$\C{e_0}$}
\setspecialsymbol{Ce_0p}{$\C{e'_0}$}
\setspecialsymbol{x_1}{$x_1$}
\setspecialsymbol{x_n}{$x_n$}
\setspecialsymbol{e_1}{$e_1$}
\setspecialsymbol{e_n}{$e_n$}
\setspecialsymbol{k_1}{$k_1$}
\setspecialsymbol{k_2}{$k_2$}
\setspecialsymbol{Ce_1}{$\C{e_1}$}
\setspecialsymbol{Ce_1p}{$\C{e'_1}$}
\setspecialsymbol{Cv}{$\C{v}$}
\setspecialsymbol{v_0}{$v_0$}
\setspecialsymbol{Cv_0}{$\C{v_0}$}
\setspecialsymbol{Cv_0p}{$\C{v'_0}$}
\setspecialsymbol{Cpv_0}{$\Cp{v_0}$}
\setspecialsymbol{Cpv_1}{$\Cp{v_1}$}
\setspecialsymbol{v_1}{$v_1$}
\setspecialsymbol{T}{$\mathcal{A}$}
\setspecialsymbol{C}{$\mathcal{C}$}
\setspecialsymbol{Cp}{$\mathcal{C}'$}
\setspecialsymbol{Ch}{$\hat{\mathcal{C}}$}
\setspecialsymbol{Ccps}{$\mathcal{C}_{\mathrm{cps}}$}
\setspecialsymbol{Cpcps}{$\mathcal{C}'_{\mathrm{cps}}$}
\setspecialsymbol{Chcps}{$\hat{\mathcal{C}}_{\mathrm{cps}}$}
\setspecialsymbol{hole}{$\hole$}
\setspecialsymbol{bottom}{$\perp$}
\setspecialsymbol{Ce_0p_x_Cpv_1}{$\C{e'_0}[x\leftarrow\Cp{v_1}]$}
\setspecialsymbol{e_0p_x_v_1}{$e'_0[x\leftarrow v_1]$}
\setspecialsymbol{Cz}{$\C{z}$}
\setspecialsymbol{CE}{$\C{E}$}
\setspecialsymbol{XI}{$\xi$}
\setspecialsymbol{xiE}{$\xi(E)$}
\setspecialsymbol{chiE}{$\chi(E)$}
\setspecialsymbol{CchiE}{$\C{\chi(E)}$}

\setspecialsymbol{TRUE}{$\mathbf{true}$}
\setspecialsymbol{FALSE}{$\mathbf{false}$}
\setspecialsymbol{PAIR}{$\mathbf{pair}$}
\setspecialsymbol{CONS}{$\mathbf{cons}$}
\setspecialsymbol{FST}{$\mathbf{fst}$}
\setspecialsymbol{SND}{$\mathbf{snd}$}
\setspecialsymbol{NIL}{$\mathbf{nil}$}

\newcommand{\true}{\mathbf{true}}
\newcommand{\false}{\mathbf{false}}
\newcommand{\nil}{\mathbf{nil}}
\newcommand{\cons}[2]{((\mathbf{cons}\,#1)\,#2)}
\newcommand{\eval}[1]{\overline{#1}}

\begin{figure}
\label{church-encodings}
\begin{align*}
\true         &= \abs{x}{\abs{y}{x}}\\
\false        &= \abs{x}{\abs{y}{y}}\\
\mathbf{cons} &= \abs{a}{\abs{b}{\abs{z}{\app{\app{z}{a}}{b}}}}\\
\mathbf{snd}  &= \abs{p}{\app{p}{\false}}\\
\nil          &= \false
\end{align*}
\caption{Church encodings of booleans and lists}
\end{figure}

%The accumulator-passing style definition of $\chi$ has the effect of ordering the marks from most- to least-recently placed.

Let $\lvrr$ denote the reduction relation for \lv\ and $\lvrrs$ its transitive closure. Similarly, let $\cmrr$ denote the reduction relation for \cm\ and $\cmrrs$ its transitive closure. We will use the more specific notation when $\rightarrow$ is potentially ambiguous.

With the source and target languages formally specified, we can now examine a language transformation in earnest.

\section{Transformation}
\label{sec-transformation}

As transformations, desugarings put the meaning of one construct in terms of another. If the meaning of the former was given only informally, the desugaring offers a new definition as formal as the definition of the latter. In this way, desugarings offer a convenient way to provide meaning to a construct and avoid enlarging the language. If, however, the sugared language already has a formal meaning, as does \cm, the desugaring must preserve it.

We will define a transformation from \cm\ to \lv\ and term it $\mathcal{C}$, as in \emph{compile}, since we are, in essence, compiling away continuation marks. In order to preserve the meaning of \cm, $\mathcal{C}$ must commute with evaluation. More precisely, for programs $p\in\lambda_{cm}$,
\[
\begin{array}{ccc}
p & \cmrrs & v\\
\downarrow_\mathcal{C} & & \downarrow_\mathcal{C}\\
\C{p} & \lvrrs & \C{v}
\end{array}
\]
should hold. If we define 
\begin{equation}
\evalcm{p}=\begin{cases}
v     &\text{if $p\cmrrs v$}\\
\perp &\text{if $p\cmrrs\cdots$}
\end{cases}
\end{equation}
and
\begin{equation}
\evalv{p}=\begin{cases}
v     &\text{if $p\lvrrs v$}\\
\perp &\text{if $p\lvrrs\cdots$}
\end{cases}
\end{equation}
we can state this more concisely by 
\begin{equation}
\C{\evalcm{p}}=\evalv{\C{p}}
\end{equation}

\subsection{Intuition}

The essence of \cm\ is that programs can apply information to and observe information about the context in which they are evaluated. Programs in \lv\ have no such facility. We can simulate this facility by explicitly passing contextual information to each term as it is evaluated. We can define $\mathcal{C}$ to transform \scheme'wcm' directives to manipulate this information and \scheme'ccm' directives to access it. Intuitively, we can transform \cm\ programs to mark-passing style.

However, marks alone do not account for the tail-call behavior specified by rule \ref{tail-enforce}. Since tail-call behavior is observable (if indirectly) by \cm\ programs, we must also provide to each term information about the position in which it is evaluated. Specifically, each transformed \scheme'wcm' directive must be notified whether it is evaluated in tail position of an enclosing \scheme'wcm' directive as it must behave specially if so. Thus, in addition to passing the current continuation marks, the transform should pass a flag to each term indicating whether it is evaluated in tail position of a \scheme'wcm' directive.

%Since this is a dynamic property of the evaluation, we do not attempt to infer it statically.

These two pieces of information suffice to correctly simulate continuation marks.

\subsection{Concept}

The definition of $\mathcal{C}$ entails transformation over each syntactic form of \cm.

With this in mind, consider a conceptual transformation of application, \scheme|C[(rator-expr rand-expr)]|, as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    (let ((rator-value ((C[rator-expr] FALSE) marks))
          (rand-value ((C[rand-expr] FALSE) marks))
      (((rator-value rand-value) flag) marks))))
\end{schemedisplay}
ignoring for the moment that \scheme'let' is in neither \lv\ or \cm. This definition captures that
\begin{enumerate}
\item before evaluation, we expect \scheme'flag' to indicate tail position information and \scheme'marks' to provide a list of the current continuation marks,
\item we would like to evaluate \scheme'C[rator-expr]' and \scheme'C[rand-expr]' in the same manner, providing to each its contextual information--specifically that neither is evaluated in tail position of a \scheme'wcm' directive and the continuation marks for each are unchanged from the parent context,
\item and, following evaluation of operator and operand and application, evaluation of the resultant term is performed with the original contextual information.
\end{enumerate}

Now consider a conceptual transformation of a \scheme'wcm' directive, \scheme|C[(wcm mark-expr body-expr)]|, as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    ((C[body-expr] TRUE) (let ((mark-value ((C[mark-expr] FALSE) marks))
                               (rest-marks (if flag (snd marks) marks)))
                           (cons mark-value rest-marks)))))
\end{schemedisplay}
with similar caveats as the previous case. This definition captures that
\begin{enumerate}
\item as in application, we expect \scheme'flag' to indicate tail position information and \scheme'marks' to provide a list of the current continuation marks,
\item we evaluate \scheme'mark-expr' with correct contextual information,
\item we discard the first continuation mark of the parent context if evaluation is occurring in tail position of a \scheme'wcm' directive,
\item and we evaluate \scheme'C[body-expr]' with the correct tail-position flag and current continuation marks.
\end{enumerate}

Finally, consider the conceptual transformation of a \scheme'ccm' directive, \scheme|C[(ccm)]|, as
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    marks))
\end{schemedisplay}
wherein we reap the fruits of simplicity from our laborious passing: this definition is gratifyingly direct.

The conceptual transformation of variables \scheme'x' and values \scheme'(lambda (x) e)' is straightforward.

Now, to address the absence of \scheme'let', \scheme'if', \scheme'cons', etc. from \lv: We can express the \scheme'let' construct in \lv\ with application. To achieve \scheme'if' and conditionals as well as list primitives \scheme'cons', \scheme'snd', and \scheme'nil', we use the Church encodings of fig. \ref{church-encodings}.

\subsection{Initiation}

In our call-by-value language, abstracting terms has the effect of suspending evaluation. When an entire program is transformed, all evaluation is suspended, awaiting arguments representing contextual information. At the top level, the context is empty, so we pass the contextual information for the empty context: \scheme'FALSE', indicating evaluation is \emph{not} occurring in \scheme'wcm' tail position, and \scheme'NIL', an empty list of marks.

We can accommodate this by defining a top-level transform $\hat{\mathcal{C}}$ in terms of $\mathcal{C}$ by
\begin{equation}
\Ch{p}=\app{\app{\C{p}}{\false}}{\nil}
\end{equation}

and stating our commutativity property as
[make this equivalence since the left side needs to be reduced?]
\begin{equation}
\label{commutativity-property}
\Ch{\evalcm{p}}=\evalv{\Ch{p}}
\end{equation}
which is equivalent to
\begin{equation}
\app{\app{\C{\evalcm{p}}}{\false}}{\nil}=\evalv{\app{\app{\C{p}}{\false}}{\nil}}
\end{equation}

\subsection{Some Final Subtleties}

Our choice to keep the core language small by omitting lists as primitive values has the consequence of complicating our transform somewhat. Because lists are defined in terms of \lc\ values which are themselves touched by the transform and because of the commutativity property that $\mathcal{C}$ must satisfy, we cannot deal with a list of continuation marks directly--we must instead deal with a transformed list of transformed continuation marks, and manipulation of this list within transformed terms must occur at the transformed level.

Additionally, after evaluation, values are ``truncated'' with their leading abstractions applied away. For instance, the transformation of the value \scheme|(lambda (x) x)| to \scheme|(lambda (flag) (lambda (marks) (lambda (x) (lambda (flag) (lambda (marks) x)))))| will yield, following evaluation, \scheme|(lambda (x) (lambda (flag) (lambda (marks) x)))|. For convenience, we define 
\begin{equation}
\Cp{\abs{x}{e}}=\abs{x}{\C{e}}
\end{equation}
and we adjust $\hat{\mathcal{C}}$ so that
\begin{equation}
\Ch{p}=\app{\app{\C{p}}{\false}}{\Cp{\nil}}
\end{equation}


\newenvironment{schemedefn}[1]{\begin{plaindef}#1}{\end{plaindef}}
\newenvironment{namedschemedefn}[2]{\begin{plaindef}\label{#1}$#2$}{\end{plaindef}}

\subsection{Definition of $\mathcal{C}$}

Finally, we present the definition of $\mathcal{C}$ over the five syntactic forms of \cm.

\begin{schemedefn}{\scheme|C[(rator-expr rand-expr)]|}

The formal transformation of application follows the \scheme'let' version exactly except the definitions of \scheme'rator-value' and \scheme'rand-value' are folded directly in.
\begin{schemedisplay}
(lambda (flags)
  (lambda (marks)
    (((((C[rator-expr] FALSE) marks)
       ((C[rand-expr] FALSE) marks))
      flags)
     marks)))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|C[(wcm mark-expr body-expr)]|}

The formal transformation of a \scheme'wcm' directive is also extremely similar to the \scheme'let' version. The Church-encoded conditional eagerly evaluates both branches, but this still achieves correct behavior.
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    ((C[body-expr] TRUE)
     (((lambda (mark-value) (lambda (rest-marks) Ch[((CONS mark-value) rest-marks)]))
       ((C[mark-expr] FALSE) marks))
      ((flag Ch[(SND marks)]) marks)))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|C[(ccm)]|}

The \scheme'let' version of the transformation of a \scheme'ccm' directive remains unchanged.
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    marks))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|C[v]|=\scheme|C[(lambda (x) e)]|}

Like other terms, values are modified to receive contextual information. However, being unaffected by context, values discard this information.
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    (lambda (x) C[e])))
\end{schemedisplay}
\end{schemedefn}


\begin{schemedefn}{\scheme|C[x]|}

Variables have the property that, when substitution occurs, they reconstitute transformed values. That is, in the midst of application in $\mathcal{C}$, terms of the form \scheme|(Cp[(lambda (x) x)] Cp[(lambda (y) y)])| appear, reducing to $\C{x}[x\leftarrow \Cp{\abs{y}{y}}]=\C{x[x\leftarrow\abs{y}{y}}=\C{\abs{y}{y}}$.
\begin{schemedisplay}
(lambda (flag)
  (lambda (marks)
    x))
\end{schemedisplay}
\end{schemedefn}

\subsection{Definition of $\mathcal{C}$ in CPS}

Many compilers transform source to continuation-passing style (CPS) in the compilation process. The use of CPS as an intermediate language enables a host of optimization analyses and makes the implementation of otherwise-heavyweight features trivial, such as first-class continuations \cite{appel2007compiling}.

We present a continuation mark transformation integrated in CPS.

\begin{schemedefn}{\scheme|Ccps[(rator-expr rand-expr)]|}
\begin{schemedisplay}
(lambda (kont)
   (lambda (flag)
     (lambda (marks)
       (((Ccps[rator-expr]
          (lambda (rator-value)
            (((Ccps[rand-expr]
               (lambda (rand-value)
                 ((((rator-value rand-value) kont) flag) marks)))
              FALSE)
             marks)))
         FALSE)
        marks))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|C[(wcm mark-expr body-expr)]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (((Ccps[mark-expr]
          (lambda (mark-value) 
            ((lambda (rest-marks) 
               (((Ccps[body-expr] kont) TRUE) Chcps[((CONS mark-value) rest-marks)]))
             ((flag Chcps[(SND marks)]) marks))))
        FALSE)
       marks))))
\end{schemedisplay}
\end{schemedefn}

\begin{schemedefn}{\scheme|Ccps[(ccm)]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (kont marks))))
\end{schemedisplay}
\end{schemedefn}

\noindent
\begin{minipage}{0.5\linewidth}
\begin{schemedefn}{\scheme|Ccps[v]|=\scheme|Ccps[(lambda (x) e)]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (kont (lambda (x) Ccps[e])))))
\end{schemedisplay}
\end{schemedefn}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{schemedefn}{\scheme|Ccps[x]|}
\begin{schemedisplay}
(lambda (kont)
  (lambda (flag)
    (lambda (marks)
      (kont x))))
\end{schemedisplay}
\end{schemedefn}
\end{minipage}
\\
\\

We include corresponding definitions for $\mathcal{C}'$ and $\hat{\mathcal{C}}$.
\\
\\
\noindent
\begin{minipage}{0.5\linewidth}
\begin{schemedefn}{\scheme|Cpcps[(lambda (x) e)]|}
\begin{schemedisplay}
(lambda (x) Ccps[e])
\end{schemedisplay}
\end{schemedefn}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{schemedefn}{\scheme|Chcps[p]|}
\begin{schemedisplay}
(((Ccps[p] (lambda (x) x)) FALSE) Cpcps[nil])
\end{schemedisplay}
\end{schemedefn}
\end{minipage}

\subsection{Example}

To better illustrate what the transformation does, we step through the reduction of a program which exhibits its more interesting aspects. One \cm\ program suited to this purpose is \scheme|(wcm 0 ((lambda (x) (wcm x (ccm))) 1))|. It reduces according to \cm\ semantics as
\begin{schemedisplay}
(wcm 0 ((lambda (x) (wcm x (ccm))) 1))
(wcm 0 (wcm 1 (ccm)))
(wcm 1 (ccm))
(wcm 1 (lambda (z) ((z 1) (lambda (x) (lambda (y) y)))))
(lambda (z) ((z 1) (lambda (x) (lambda (y) y))))
\end{schemedisplay}

Now consider the reduction of the same program transformed. We apply the transformation just-in-time as we reduce to prevent term size explosion and promote clarity and omit the uninteresting reductions.
\begin{schemedisplay}
Ch[(wcm 0 ((lambda (x) (wcm x (ccm))) 1))]
; By definition this is
((C[(wcm 0 ((lambda (x) (wcm x (ccm))) 1))] FALSE) Cp[NIL])

(((lambda (flag)
    (lambda (marks)
      ((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
       (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
         ((C[0] FALSE) marks)) ((flag Ch[(SND marks)]) marks)))))
  FALSE) Cp[NIL])

((lambda (marks)
   ((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
    (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
      ((C[0] FALSE) marks)) ((FALSE Ch[(SND marks)]) marks))))
 Cp[NIL])

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   ((C[0] FALSE) Cp[NIL])) ((FALSE Ch[(SND NIL)]) Cp[NIL])))

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   (((lambda (flag) (lambda (marks) 0)) FALSE) Cp[NIL])) ((FALSE Ch[(SND NIL)]) Cp[NIL])))

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   ((lambda (marks) 0) Cp[NIL])) ((FALSE Ch[(SND NIL)]) Cp[NIL])))

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   0) ((FALSE Ch[(SND NIL)]) Cp[NIL])))

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
 ((lambda (rest-marks) Cp[((CONS 0) rest-marks)])
  ((FALSE Ch[(SND NIL)]) Cp[NIL])))

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE)
 ((lambda (rest-marks) Cp[((CONS 0) rest-marks)])
  Cp[NIL]))

((C[((lambda (x) (wcm x (ccm))) 1)] TRUE) Cp[((CONS 0) NIL)])

(((lambda (flag)
    (lambda (marks)
      (((((C[(lambda (x) (wcm x (ccm)))] FALSE) marks)
         ((C[1] FALSE) marks))
        flag)
       marks))) TRUE) Cp[((CONS 0) NIL)])

(((((C[(lambda (x) (wcm x (ccm)))] FALSE) Cp[((CONS 0) NIL)])
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  TRUE) Cp[((CONS 0) NIL)])

((((((lambda (flag) (lambda (marks) (lambda (x) C[(wcm x (ccm))]))) FALSE) Cp[((CONS 0) NIL)])
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  TRUE) Cp[((CONS 0) NIL)])

(((((lambda (marks) (lambda (x) C[(wcm x (ccm))])) Cp[((CONS 0) NIL)])
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  TRUE) Cp[((CONS 0) NIL)])

((((lambda (x) C[(wcm x (ccm))])
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  TRUE) Cp[((CONS 0) NIL)])

((((lambda (x) C[(wcm x (ccm))])
   (((lambda (flag) (lambda (marks) 1)) FALSE) Cp[((CONS 0) NIL)]))
  TRUE) Cp[((CONS 0) NIL)])

((((lambda (x) C[(wcm x (ccm))])
   ((lambda (marks) 1) Cp[((CONS 0) NIL)]))
  TRUE) Cp[((CONS 0) NIL)])

((((lambda (x) C[(wcm x (ccm))])
   1) TRUE) Cp[((CONS 0) NIL)])

((C[(wcm 1 (ccm))]
   TRUE) Cp[((CONS 0) NIL)])

(((lambda (flag)
    (lambda (marks)
      ((C[(ccm)] TRUE)
       (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
         ((C[1] FALSE) marks))
        ((flag Ch[(SND marks)]) marks)))))
  TRUE) Cp[((CONS 0) NIL)])

((lambda (marks)
   ((C[(ccm)] TRUE)
    (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
      ((C[1] FALSE) marks))
     ((TRUE Ch[(SND marks)]) marks))))
 Cp[((CONS 0) NIL)])

((C[(ccm)] TRUE)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

(((lambda (flag) (lambda (marks) marks))
  TRUE)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

((lambda (marks) marks)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   ((C[1] FALSE) Cp[((CONS 0) NIL)]))
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

((lambda (marks) marks)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   (((lambda (flag) (lambda (marks) 1)) FALSE) Cp[((CONS 0) NIL)]))
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

((lambda (marks) marks)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   ((lambda (marks) 1) Cp[((CONS 0) NIL)]))
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

((lambda (marks) marks)
 (((lambda (mark-value) (lambda (rest-marks) Cp[((CONS mark-value) rest-marks)]))
   1)
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

((lambda (marks) marks)
 ((lambda (rest-marks) Cp[((CONS 1) rest-marks)])
  ((TRUE Ch[(SND ((CONS 0) NIL))]) Cp[((CONS 0) NIL)])))

((lambda (marks) marks)
 ((lambda (rest-marks) Cp[((CONS 1) rest-marks)])
  Ch[(SND ((CONS 0) NIL))]))

((lambda (marks) marks)
 ((lambda (rest-marks) Cp[((CONS 1) rest-marks)])
  Cp[NIL]))

((lambda (marks) marks)
 Cp[((CONS 1) NIL)])

Cp[((CONS 1) NIL)]
\end{schemedisplay}

\section{Testing}
\label{sec-testing}

A pragmatic approach to the discovery of a correct transformation involves consistent feedback and testing to validate candidate transforms. Testing is no substitute for proof, but, as Klein et al. \cite{klein2012run} show, proof is no substitute for testing. Lightweight mechanization is a fruitful middle ground between pencil-and-paper analysis and fully-mechanized formal proof. We use Redex \cite{findler2010redex}, a domain-specific language for exploring language semantics, to provide feedback, thoroughly exercise candidates, and perform exploratory analysis.

The correctness of the transform lies in the property that it commutes with evaluation. In order to test for this property, we must construct evaluation models for the source language \cm\ and the target language \lv. Since \cm\ is an extension of \lv, many of its forms and semantics are inherited. Redex allows us to exploit this fact by defining a model for \lv\ first and then extending that model with the enhancements of \cm.

After constructing the models, we are prepared to test various semantic properties of these two languages. Of course, we are particularly interested in testing the commutativity of our transformation.

%We observe that a mark-passing approach, much like a continuation-passing approach, abstracts terms and so requires a transformed term to be primed with an argument to initiate reduction. For this reason, we accompany each transform with an initialization function which primes a term appropriately for the corresponding transform.

\setspecialsymbol{lambdav}{$\lambda$v}
\setspecialsymbol{lambdacm}{$\lambda$cm}
\setkeyword{meaning-preserved? alpha-eq? eval c-hat redex-check apply-reduction-relation*}

We can test that the property described by equation \ref{commutativity-property} holds for a given program \scheme'p' with 
\begin{schemedisplay}
(define (meaning-preserved? p)
  (alpha-eq? (eval lambdav (c-hat (eval lambdacm p))) (eval lambdav (c-hat p)))
\end{schemedisplay}
where \scheme'alpha-eq?' determines $\alpha$-equivalence between two \lc\ terms and \scheme'eval' is an alias for the Redex native \scheme'apply-reduction-relation*'.

Redex provides convenient functions to initiate random testing.

\begin{schemedisplay}
(redex-check lambdacm e (meaning-preserved? e))
\end{schemedisplay}

\scheme'redex-check' generates random terms according to the grammar of the given language (\scheme'lambdacm') and category (\scheme'e') in search of counterexamples to the predicate. It gradually increases the size of the terms it generates, which we found useful in obtaining minimal test cases. We subjected both the direct and CPS transformation to random testing and each eventually withstood 10,000 random tests. Interestingly, no incorrect transformation withstood more than 500 random tests before failing.

\section{Proof}
\label{sec-proof}

With a reasonable intuition and definitions hardened by random testing, we prove correctness of the continuation-passing variant of the transform $\mathcal{C}_{\mathrm{cps}}$.

Because of space limitations, we offer only a sketch of the proof here. [The full proof can be found in a technical report at ...]

We begin by expressing the commutativity property we have sought to preserve as a theorem:

\begin{theorem}
For all programs $p\in\lambda_{cm}$, $\Chcps{\mathrm{eval}_{cm}(p)}=\mathrm{eval}_{v}(\Chcps{p})$.
\end{theorem}

We prove this by overloading $\mathcal{C}_{\mathrm{cps}}$ to accommodate first evaluation contexts and then context-term pairs (denoted in unorthodox style) by
\begin{schemedefn}{\scheme|Ccps[E[e]]|}
\begin{schemedisplay}
(((Ccps[e] Ccps[E]) xiE) Cpcps[chiE])
\end{schemedisplay}
\end{schemedefn}
\noindent
which allows us to formally relate $E[e]$ and $\Ccps{E[e]}$. We then prove a lemma
\begin{lemma}[Simulation]
For all contexts $E\in\lambda_{cm}$ and expressions $e\in\lambda_{cm}$, $E[e]\cmrr E'[e']\implies\C{E[e]}\lvrrs\C{E'[e']}$
\end{lemma}
by induction over contexts $E$ and terms $e$. This lemma justifies the evolution of the evaluation context and each rule in the reduction relation except rule \ref{reduction}. We express this with
\begin{lemma}[Substitution]
\label{lem:substitution}
For all $e,x,v\in\lambda_{cm}$, $\C{e[x\leftarrow v]}=\C{e}[x\leftarrow \Cp{v}]$.
\end{lemma}

With these lemmas, the theorem follows quickly.

\section{Back to JavaScript}
\label{sec-javascript}

With a correct transformation of continuation marks defined over the \lc, little effort is required to add continuation marks to an eager, higher-order language such as JavaScript.

We add two keywords to manipulate continuation marks: the familiar \texttt{wcm} and \texttt{ccm}. We chose block syntax for \texttt{wcm} to convey that it is a special form, like a conditional, instead of a function-like interface. A lone \texttt{ccm} evaluates to the current continuation marks.

Tail-call elimination is not part of the JavaScript specification which complicates the treatment of the tail-call behavior. We simulate proper tail-call behavior by using the flag to encode whether a function call is in tail position.

A properly-recursive factorial can be implemented in this JavaScript extension as
\begin{verbatim}
var fac = function( n ) {
  if( n == 0 ) {
    console.log( ccm );
    return 1;
  }
  else {
    return wcm { n }
               { n * fac( n - 1 ) };
  }
}
\end{verbatim}

A direct-style transformation of this function desugars these constructs into vanilla JavaScript, leveraging native arrays for lists of continuation marks.
\begin{verbatim}
var fac = function( flag, marks ) {
  return function( n ) {
    if( n == 0 ) {
      console.log( (function( flag, marks ) { return marks; })( false, marks ) );
      return 1;
    }
    else {
      return (function( flag, marks ) {
        return (function( mark_value, rest_marks ) {
          return n * fac( false, [ mark_value ].concat( rest_marks ) )( n - 1 );
        })( n, flag ? marks.slice( 1 ) : marks );
      })( flag, marks );
    }
  }
}
\end{verbatim}

As expected, the output of a manual initiation of this function is
\begin{verbatim}
> fac( false, [] )( 5 )
[ 1, 2, 3, 4, 5 ]
120
\end{verbatim}

A tail-recursive factorial is expressible in this extension as
\begin{verbatim}
var fac = function( n, acc ) {
  if( n == 0 ) {
    console.log( ccm );
    return acc;
  }
  else {
    return wcm { n }
               { fac( n - 1, n * acc ) };
  }
}
\end{verbatim}
and transforms to
\begin{verbatim}
var fac = function( flag, marks ) {
  return function( n, acc ) {
    if( n == 0 ) {
      console.log( (function( flag, marks ) { return marks; })( false, marks ) );
      return acc;
    }
    else {
      return (function( flag, marks ) {
        return (function( mark_value, rest_marks ) {
          return fac( true, [ mark_value ].concat( rest_marks ) )( n - 1, n * acc );
        })( n, flag ? marks.slice( 1 ) : marks );
      })( flag, marks );
    }
  }
}
\end{verbatim}

The output of a manual initiation of this function is
\begin{verbatim}
> fac( false, [] )( 5, 1 )
[ 1 ]
120
\end{verbatim}

In this example, the API to compute factorials has changed, but the change is localized. With top-level control of a program, we can transform the relevant part of the system, leaving the rest the same. This preserves interoperability with foreign functions, i.e., third-party JavaScript libraries.
 
\section{Related Work}

Monads, introduced by Moggi \cite{moggi1989computational}, are another way to model semantics. Their appeal is significant: they allow one to implement a particular model of computation with with a pure computational logic, such as the \lc.

Expressing continuation marks in a monadic way is simple enough. In Haskell,
\begin{lstlisting}[language=Haskell]
data CM m a = CM ((Bool,[m]) -> a)

instance Monad (CM m) where
  return x = CM (\_ -> x)
  (CM m) >>= f = CM (\(flag,vs) ->
      let (CM m') = f (m (False,vs)) in m' (flag,vs))

wcm :: m -> CM m a -> CM m a
wcm v (CM m) = CM (\(f,vs) -> m (True, v:(if f then (tail vs) else vs)))

ccm :: CM m [m]
ccm = CM (\(_,vs) -> vs)

runCM :: CM m a -> a
runCM (CM m) = m (False,[])
\end{lstlisting}
is one way, using our approach. The factorial functions leveraging this implementation exhibit the correct continuation mark behavior but this is \emph{not} a monad. Specifically, the right identity law, \texttt{m >>= return = m}, does not hold since \texttt{CM} conceptually adds a stack frame in bind (\texttt{>>=}). Ager et al. \cite{ager2003functional} implemented a similar stack-inspection monad in terms of a lifted state monad, but resorted to manual management of the stack frames.

\section{Future Work and Conclusion}

Although we used some level of mechanization in the proof of the theorem, a formal proof assistant, such as Coq \cite{barras1997coq}, would increase confidence out of the gate that the transformation was correct.

Continuation marks support a bevy of instrumentation tools and advanced language features in a generalized, portable way. Despite their demonstrated utility, they have not yet found their way into most languages. A verified characterization of continuation marks in a pure computational language provides implementors of higher-order languages a correct compiler for continuation marks.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}
